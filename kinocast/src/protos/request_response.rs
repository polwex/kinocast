// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `request_response.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct Empty {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Empty {
    fn default() -> &'a Empty {
        <Empty as ::protobuf::Message>::default_instance()
    }
}

impl Empty {
    pub fn new() -> Empty {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Empty {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Empty {
        Empty::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Empty>(
                "Empty",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Empty {
        static instance: ::protobuf::rt::LazyV2<Empty> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Empty::new)
    }
}

impl ::protobuf::Clear for Empty {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Empty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Empty {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeRequest {
    // message fields
    pub event_types: ::std::vec::Vec<super::hub_event::HubEventType>,
    pub from_id: u64,
    pub total_shards: u64,
    pub shard_index: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeRequest {
    fn default() -> &'a SubscribeRequest {
        <SubscribeRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeRequest {
    pub fn new() -> SubscribeRequest {
        ::std::default::Default::default()
    }

    // repeated .HubEventType event_types = 1;


    pub fn get_event_types(&self) -> &[super::hub_event::HubEventType] {
        &self.event_types
    }
    pub fn clear_event_types(&mut self) {
        self.event_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_event_types(&mut self, v: ::std::vec::Vec<super::hub_event::HubEventType>) {
        self.event_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_event_types(&mut self) -> &mut ::std::vec::Vec<super::hub_event::HubEventType> {
        &mut self.event_types
    }

    // Take field
    pub fn take_event_types(&mut self) -> ::std::vec::Vec<super::hub_event::HubEventType> {
        ::std::mem::replace(&mut self.event_types, ::std::vec::Vec::new())
    }

    // uint64 from_id = 2;


    pub fn get_from_id(&self) -> u64 {
        self.from_id
    }
    pub fn clear_from_id(&mut self) {
        self.from_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_from_id(&mut self, v: u64) {
        self.from_id = v;
    }

    // uint64 total_shards = 3;


    pub fn get_total_shards(&self) -> u64 {
        self.total_shards
    }
    pub fn clear_total_shards(&mut self) {
        self.total_shards = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_shards(&mut self, v: u64) {
        self.total_shards = v;
    }

    // uint64 shard_index = 4;


    pub fn get_shard_index(&self) -> u64 {
        self.shard_index
    }
    pub fn clear_shard_index(&mut self) {
        self.shard_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_shard_index(&mut self, v: u64) {
        self.shard_index = v;
    }
}

impl ::protobuf::Message for SubscribeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.event_types, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.from_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_shards = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.shard_index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.event_types {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        if self.from_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.from_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_shards != 0 {
            my_size += ::protobuf::rt::value_size(3, self.total_shards, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.shard_index != 0 {
            my_size += ::protobuf::rt::value_size(4, self.shard_index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.event_types {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(v))?;
        };
        if self.from_id != 0 {
            os.write_uint64(2, self.from_id)?;
        }
        if self.total_shards != 0 {
            os.write_uint64(3, self.total_shards)?;
        }
        if self.shard_index != 0 {
            os.write_uint64(4, self.shard_index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeRequest {
        SubscribeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::hub_event::HubEventType>>(
                "event_types",
                |m: &SubscribeRequest| { &m.event_types },
                |m: &mut SubscribeRequest| { &mut m.event_types },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "from_id",
                |m: &SubscribeRequest| { &m.from_id },
                |m: &mut SubscribeRequest| { &mut m.from_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "total_shards",
                |m: &SubscribeRequest| { &m.total_shards },
                |m: &mut SubscribeRequest| { &mut m.total_shards },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "shard_index",
                |m: &SubscribeRequest| { &m.shard_index },
                |m: &mut SubscribeRequest| { &mut m.shard_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubscribeRequest>(
                "SubscribeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubscribeRequest {
        static instance: ::protobuf::rt::LazyV2<SubscribeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubscribeRequest::new)
    }
}

impl ::protobuf::Clear for SubscribeRequest {
    fn clear(&mut self) {
        self.event_types.clear();
        self.from_id = 0;
        self.total_shards = 0;
        self.shard_index = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EventRequest {
    // message fields
    pub id: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventRequest {
    fn default() -> &'a EventRequest {
        <EventRequest as ::protobuf::Message>::default_instance()
    }
}

impl EventRequest {
    pub fn new() -> EventRequest {
        ::std::default::Default::default()
    }

    // uint64 id = 1;


    pub fn get_id(&self) -> u64 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = v;
    }
}

impl ::protobuf::Message for EventRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint64(1, self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventRequest {
        EventRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &EventRequest| { &m.id },
                |m: &mut EventRequest| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EventRequest>(
                "EventRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EventRequest {
        static instance: ::protobuf::rt::LazyV2<EventRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventRequest::new)
    }
}

impl ::protobuf::Clear for EventRequest {
    fn clear(&mut self) {
        self.id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EventRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HubInfoRequest {
    // message fields
    pub db_stats: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HubInfoRequest {
    fn default() -> &'a HubInfoRequest {
        <HubInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl HubInfoRequest {
    pub fn new() -> HubInfoRequest {
        ::std::default::Default::default()
    }

    // bool db_stats = 1;


    pub fn get_db_stats(&self) -> bool {
        self.db_stats
    }
    pub fn clear_db_stats(&mut self) {
        self.db_stats = false;
    }

    // Param is passed by value, moved
    pub fn set_db_stats(&mut self, v: bool) {
        self.db_stats = v;
    }
}

impl ::protobuf::Message for HubInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.db_stats = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.db_stats != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.db_stats != false {
            os.write_bool(1, self.db_stats)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HubInfoRequest {
        HubInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "db_stats",
                |m: &HubInfoRequest| { &m.db_stats },
                |m: &mut HubInfoRequest| { &mut m.db_stats },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HubInfoRequest>(
                "HubInfoRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HubInfoRequest {
        static instance: ::protobuf::rt::LazyV2<HubInfoRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HubInfoRequest::new)
    }
}

impl ::protobuf::Clear for HubInfoRequest {
    fn clear(&mut self) {
        self.db_stats = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HubInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HubInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HubInfoResponse {
    // message fields
    pub version: ::std::string::String,
    pub is_syncing: bool,
    pub nickname: ::std::string::String,
    pub root_hash: ::std::string::String,
    pub db_stats: ::protobuf::SingularPtrField<DbStats>,
    pub peerId: ::std::string::String,
    pub hub_operator_fid: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HubInfoResponse {
    fn default() -> &'a HubInfoResponse {
        <HubInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl HubInfoResponse {
    pub fn new() -> HubInfoResponse {
        ::std::default::Default::default()
    }

    // string version = 1;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // bool is_syncing = 2;


    pub fn get_is_syncing(&self) -> bool {
        self.is_syncing
    }
    pub fn clear_is_syncing(&mut self) {
        self.is_syncing = false;
    }

    // Param is passed by value, moved
    pub fn set_is_syncing(&mut self, v: bool) {
        self.is_syncing = v;
    }

    // string nickname = 3;


    pub fn get_nickname(&self) -> &str {
        &self.nickname
    }
    pub fn clear_nickname(&mut self) {
        self.nickname.clear();
    }

    // Param is passed by value, moved
    pub fn set_nickname(&mut self, v: ::std::string::String) {
        self.nickname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nickname(&mut self) -> &mut ::std::string::String {
        &mut self.nickname
    }

    // Take field
    pub fn take_nickname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.nickname, ::std::string::String::new())
    }

    // string root_hash = 4;


    pub fn get_root_hash(&self) -> &str {
        &self.root_hash
    }
    pub fn clear_root_hash(&mut self) {
        self.root_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_root_hash(&mut self, v: ::std::string::String) {
        self.root_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_root_hash(&mut self) -> &mut ::std::string::String {
        &mut self.root_hash
    }

    // Take field
    pub fn take_root_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.root_hash, ::std::string::String::new())
    }

    // .DbStats db_stats = 5;


    pub fn get_db_stats(&self) -> &DbStats {
        self.db_stats.as_ref().unwrap_or_else(|| <DbStats as ::protobuf::Message>::default_instance())
    }
    pub fn clear_db_stats(&mut self) {
        self.db_stats.clear();
    }

    pub fn has_db_stats(&self) -> bool {
        self.db_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_db_stats(&mut self, v: DbStats) {
        self.db_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_db_stats(&mut self) -> &mut DbStats {
        if self.db_stats.is_none() {
            self.db_stats.set_default();
        }
        self.db_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_db_stats(&mut self) -> DbStats {
        self.db_stats.take().unwrap_or_else(|| DbStats::new())
    }

    // string peerId = 6;


    pub fn get_peerId(&self) -> &str {
        &self.peerId
    }
    pub fn clear_peerId(&mut self) {
        self.peerId.clear();
    }

    // Param is passed by value, moved
    pub fn set_peerId(&mut self, v: ::std::string::String) {
        self.peerId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_peerId(&mut self) -> &mut ::std::string::String {
        &mut self.peerId
    }

    // Take field
    pub fn take_peerId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.peerId, ::std::string::String::new())
    }

    // uint64 hub_operator_fid = 7;


    pub fn get_hub_operator_fid(&self) -> u64 {
        self.hub_operator_fid
    }
    pub fn clear_hub_operator_fid(&mut self) {
        self.hub_operator_fid = 0;
    }

    // Param is passed by value, moved
    pub fn set_hub_operator_fid(&mut self, v: u64) {
        self.hub_operator_fid = v;
    }
}

impl ::protobuf::Message for HubInfoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.db_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_syncing = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.nickname)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.root_hash)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.db_stats)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.peerId)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.hub_operator_fid = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version);
        }
        if self.is_syncing != false {
            my_size += 2;
        }
        if !self.nickname.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.nickname);
        }
        if !self.root_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.root_hash);
        }
        if let Some(ref v) = self.db_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.peerId.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.peerId);
        }
        if self.hub_operator_fid != 0 {
            my_size += ::protobuf::rt::value_size(7, self.hub_operator_fid, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.version.is_empty() {
            os.write_string(1, &self.version)?;
        }
        if self.is_syncing != false {
            os.write_bool(2, self.is_syncing)?;
        }
        if !self.nickname.is_empty() {
            os.write_string(3, &self.nickname)?;
        }
        if !self.root_hash.is_empty() {
            os.write_string(4, &self.root_hash)?;
        }
        if let Some(ref v) = self.db_stats.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.peerId.is_empty() {
            os.write_string(6, &self.peerId)?;
        }
        if self.hub_operator_fid != 0 {
            os.write_uint64(7, self.hub_operator_fid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HubInfoResponse {
        HubInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &HubInfoResponse| { &m.version },
                |m: &mut HubInfoResponse| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_syncing",
                |m: &HubInfoResponse| { &m.is_syncing },
                |m: &mut HubInfoResponse| { &mut m.is_syncing },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nickname",
                |m: &HubInfoResponse| { &m.nickname },
                |m: &mut HubInfoResponse| { &mut m.nickname },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "root_hash",
                |m: &HubInfoResponse| { &m.root_hash },
                |m: &mut HubInfoResponse| { &mut m.root_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DbStats>>(
                "db_stats",
                |m: &HubInfoResponse| { &m.db_stats },
                |m: &mut HubInfoResponse| { &mut m.db_stats },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "peerId",
                |m: &HubInfoResponse| { &m.peerId },
                |m: &mut HubInfoResponse| { &mut m.peerId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "hub_operator_fid",
                |m: &HubInfoResponse| { &m.hub_operator_fid },
                |m: &mut HubInfoResponse| { &mut m.hub_operator_fid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HubInfoResponse>(
                "HubInfoResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HubInfoResponse {
        static instance: ::protobuf::rt::LazyV2<HubInfoResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HubInfoResponse::new)
    }
}

impl ::protobuf::Clear for HubInfoResponse {
    fn clear(&mut self) {
        self.version.clear();
        self.is_syncing = false;
        self.nickname.clear();
        self.root_hash.clear();
        self.db_stats.clear();
        self.peerId.clear();
        self.hub_operator_fid = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HubInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HubInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DbStats {
    // message fields
    pub num_messages: u64,
    pub num_fid_events: u64,
    pub num_fname_events: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DbStats {
    fn default() -> &'a DbStats {
        <DbStats as ::protobuf::Message>::default_instance()
    }
}

impl DbStats {
    pub fn new() -> DbStats {
        ::std::default::Default::default()
    }

    // uint64 num_messages = 1;


    pub fn get_num_messages(&self) -> u64 {
        self.num_messages
    }
    pub fn clear_num_messages(&mut self) {
        self.num_messages = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_messages(&mut self, v: u64) {
        self.num_messages = v;
    }

    // uint64 num_fid_events = 2;


    pub fn get_num_fid_events(&self) -> u64 {
        self.num_fid_events
    }
    pub fn clear_num_fid_events(&mut self) {
        self.num_fid_events = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_fid_events(&mut self, v: u64) {
        self.num_fid_events = v;
    }

    // uint64 num_fname_events = 3;


    pub fn get_num_fname_events(&self) -> u64 {
        self.num_fname_events
    }
    pub fn clear_num_fname_events(&mut self) {
        self.num_fname_events = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_fname_events(&mut self, v: u64) {
        self.num_fname_events = v;
    }
}

impl ::protobuf::Message for DbStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.num_messages = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.num_fid_events = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.num_fname_events = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.num_messages != 0 {
            my_size += ::protobuf::rt::value_size(1, self.num_messages, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_fid_events != 0 {
            my_size += ::protobuf::rt::value_size(2, self.num_fid_events, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_fname_events != 0 {
            my_size += ::protobuf::rt::value_size(3, self.num_fname_events, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.num_messages != 0 {
            os.write_uint64(1, self.num_messages)?;
        }
        if self.num_fid_events != 0 {
            os.write_uint64(2, self.num_fid_events)?;
        }
        if self.num_fname_events != 0 {
            os.write_uint64(3, self.num_fname_events)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DbStats {
        DbStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "num_messages",
                |m: &DbStats| { &m.num_messages },
                |m: &mut DbStats| { &mut m.num_messages },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "num_fid_events",
                |m: &DbStats| { &m.num_fid_events },
                |m: &mut DbStats| { &mut m.num_fid_events },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "num_fname_events",
                |m: &DbStats| { &m.num_fname_events },
                |m: &mut DbStats| { &mut m.num_fname_events },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DbStats>(
                "DbStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DbStats {
        static instance: ::protobuf::rt::LazyV2<DbStats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DbStats::new)
    }
}

impl ::protobuf::Clear for DbStats {
    fn clear(&mut self) {
        self.num_messages = 0;
        self.num_fid_events = 0;
        self.num_fname_events = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DbStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DbStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SyncStatusRequest {
    // message fields
    pub peerId: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncStatusRequest {
    fn default() -> &'a SyncStatusRequest {
        <SyncStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl SyncStatusRequest {
    pub fn new() -> SyncStatusRequest {
        ::std::default::Default::default()
    }

    // string peerId = 1;


    pub fn get_peerId(&self) -> &str {
        &self.peerId
    }
    pub fn clear_peerId(&mut self) {
        self.peerId.clear();
    }

    // Param is passed by value, moved
    pub fn set_peerId(&mut self, v: ::std::string::String) {
        self.peerId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_peerId(&mut self) -> &mut ::std::string::String {
        &mut self.peerId
    }

    // Take field
    pub fn take_peerId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.peerId, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SyncStatusRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.peerId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.peerId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.peerId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.peerId.is_empty() {
            os.write_string(1, &self.peerId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncStatusRequest {
        SyncStatusRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "peerId",
                |m: &SyncStatusRequest| { &m.peerId },
                |m: &mut SyncStatusRequest| { &mut m.peerId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncStatusRequest>(
                "SyncStatusRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncStatusRequest {
        static instance: ::protobuf::rt::LazyV2<SyncStatusRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncStatusRequest::new)
    }
}

impl ::protobuf::Clear for SyncStatusRequest {
    fn clear(&mut self) {
        self.peerId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncStatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SyncStatusResponse {
    // message fields
    pub is_syncing: bool,
    pub sync_status: ::protobuf::RepeatedField<SyncStatus>,
    pub engine_started: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncStatusResponse {
    fn default() -> &'a SyncStatusResponse {
        <SyncStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl SyncStatusResponse {
    pub fn new() -> SyncStatusResponse {
        ::std::default::Default::default()
    }

    // bool is_syncing = 1;


    pub fn get_is_syncing(&self) -> bool {
        self.is_syncing
    }
    pub fn clear_is_syncing(&mut self) {
        self.is_syncing = false;
    }

    // Param is passed by value, moved
    pub fn set_is_syncing(&mut self, v: bool) {
        self.is_syncing = v;
    }

    // repeated .SyncStatus sync_status = 2;


    pub fn get_sync_status(&self) -> &[SyncStatus] {
        &self.sync_status
    }
    pub fn clear_sync_status(&mut self) {
        self.sync_status.clear();
    }

    // Param is passed by value, moved
    pub fn set_sync_status(&mut self, v: ::protobuf::RepeatedField<SyncStatus>) {
        self.sync_status = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sync_status(&mut self) -> &mut ::protobuf::RepeatedField<SyncStatus> {
        &mut self.sync_status
    }

    // Take field
    pub fn take_sync_status(&mut self) -> ::protobuf::RepeatedField<SyncStatus> {
        ::std::mem::replace(&mut self.sync_status, ::protobuf::RepeatedField::new())
    }

    // bool engine_started = 3;


    pub fn get_engine_started(&self) -> bool {
        self.engine_started
    }
    pub fn clear_engine_started(&mut self) {
        self.engine_started = false;
    }

    // Param is passed by value, moved
    pub fn set_engine_started(&mut self, v: bool) {
        self.engine_started = v;
    }
}

impl ::protobuf::Message for SyncStatusResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.sync_status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_syncing = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sync_status)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.engine_started = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.is_syncing != false {
            my_size += 2;
        }
        for value in &self.sync_status {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.engine_started != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.is_syncing != false {
            os.write_bool(1, self.is_syncing)?;
        }
        for v in &self.sync_status {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.engine_started != false {
            os.write_bool(3, self.engine_started)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncStatusResponse {
        SyncStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_syncing",
                |m: &SyncStatusResponse| { &m.is_syncing },
                |m: &mut SyncStatusResponse| { &mut m.is_syncing },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SyncStatus>>(
                "sync_status",
                |m: &SyncStatusResponse| { &m.sync_status },
                |m: &mut SyncStatusResponse| { &mut m.sync_status },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "engine_started",
                |m: &SyncStatusResponse| { &m.engine_started },
                |m: &mut SyncStatusResponse| { &mut m.engine_started },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncStatusResponse>(
                "SyncStatusResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncStatusResponse {
        static instance: ::protobuf::rt::LazyV2<SyncStatusResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncStatusResponse::new)
    }
}

impl ::protobuf::Clear for SyncStatusResponse {
    fn clear(&mut self) {
        self.is_syncing = false;
        self.sync_status.clear();
        self.engine_started = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SyncStatus {
    // message fields
    pub peerId: ::std::string::String,
    pub inSync: ::std::string::String,
    pub shouldSync: bool,
    pub divergencePrefix: ::std::string::String,
    pub divergenceSecondsAgo: i32,
    pub theirMessages: u64,
    pub ourMessages: u64,
    pub lastBadSync: i64,
    pub score: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncStatus {
    fn default() -> &'a SyncStatus {
        <SyncStatus as ::protobuf::Message>::default_instance()
    }
}

impl SyncStatus {
    pub fn new() -> SyncStatus {
        ::std::default::Default::default()
    }

    // string peerId = 1;


    pub fn get_peerId(&self) -> &str {
        &self.peerId
    }
    pub fn clear_peerId(&mut self) {
        self.peerId.clear();
    }

    // Param is passed by value, moved
    pub fn set_peerId(&mut self, v: ::std::string::String) {
        self.peerId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_peerId(&mut self) -> &mut ::std::string::String {
        &mut self.peerId
    }

    // Take field
    pub fn take_peerId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.peerId, ::std::string::String::new())
    }

    // string inSync = 2;


    pub fn get_inSync(&self) -> &str {
        &self.inSync
    }
    pub fn clear_inSync(&mut self) {
        self.inSync.clear();
    }

    // Param is passed by value, moved
    pub fn set_inSync(&mut self, v: ::std::string::String) {
        self.inSync = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inSync(&mut self) -> &mut ::std::string::String {
        &mut self.inSync
    }

    // Take field
    pub fn take_inSync(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.inSync, ::std::string::String::new())
    }

    // bool shouldSync = 3;


    pub fn get_shouldSync(&self) -> bool {
        self.shouldSync
    }
    pub fn clear_shouldSync(&mut self) {
        self.shouldSync = false;
    }

    // Param is passed by value, moved
    pub fn set_shouldSync(&mut self, v: bool) {
        self.shouldSync = v;
    }

    // string divergencePrefix = 4;


    pub fn get_divergencePrefix(&self) -> &str {
        &self.divergencePrefix
    }
    pub fn clear_divergencePrefix(&mut self) {
        self.divergencePrefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_divergencePrefix(&mut self, v: ::std::string::String) {
        self.divergencePrefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_divergencePrefix(&mut self) -> &mut ::std::string::String {
        &mut self.divergencePrefix
    }

    // Take field
    pub fn take_divergencePrefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.divergencePrefix, ::std::string::String::new())
    }

    // int32 divergenceSecondsAgo = 5;


    pub fn get_divergenceSecondsAgo(&self) -> i32 {
        self.divergenceSecondsAgo
    }
    pub fn clear_divergenceSecondsAgo(&mut self) {
        self.divergenceSecondsAgo = 0;
    }

    // Param is passed by value, moved
    pub fn set_divergenceSecondsAgo(&mut self, v: i32) {
        self.divergenceSecondsAgo = v;
    }

    // uint64 theirMessages = 6;


    pub fn get_theirMessages(&self) -> u64 {
        self.theirMessages
    }
    pub fn clear_theirMessages(&mut self) {
        self.theirMessages = 0;
    }

    // Param is passed by value, moved
    pub fn set_theirMessages(&mut self, v: u64) {
        self.theirMessages = v;
    }

    // uint64 ourMessages = 7;


    pub fn get_ourMessages(&self) -> u64 {
        self.ourMessages
    }
    pub fn clear_ourMessages(&mut self) {
        self.ourMessages = 0;
    }

    // Param is passed by value, moved
    pub fn set_ourMessages(&mut self, v: u64) {
        self.ourMessages = v;
    }

    // int64 lastBadSync = 8;


    pub fn get_lastBadSync(&self) -> i64 {
        self.lastBadSync
    }
    pub fn clear_lastBadSync(&mut self) {
        self.lastBadSync = 0;
    }

    // Param is passed by value, moved
    pub fn set_lastBadSync(&mut self, v: i64) {
        self.lastBadSync = v;
    }

    // int64 score = 9;


    pub fn get_score(&self) -> i64 {
        self.score
    }
    pub fn clear_score(&mut self) {
        self.score = 0;
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: i64) {
        self.score = v;
    }
}

impl ::protobuf::Message for SyncStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.peerId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.inSync)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.shouldSync = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.divergencePrefix)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.divergenceSecondsAgo = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.theirMessages = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ourMessages = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.lastBadSync = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.score = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.peerId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.peerId);
        }
        if !self.inSync.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.inSync);
        }
        if self.shouldSync != false {
            my_size += 2;
        }
        if !self.divergencePrefix.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.divergencePrefix);
        }
        if self.divergenceSecondsAgo != 0 {
            my_size += ::protobuf::rt::value_size(5, self.divergenceSecondsAgo, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.theirMessages != 0 {
            my_size += ::protobuf::rt::value_size(6, self.theirMessages, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ourMessages != 0 {
            my_size += ::protobuf::rt::value_size(7, self.ourMessages, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.lastBadSync != 0 {
            my_size += ::protobuf::rt::value_size(8, self.lastBadSync, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.score != 0 {
            my_size += ::protobuf::rt::value_size(9, self.score, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.peerId.is_empty() {
            os.write_string(1, &self.peerId)?;
        }
        if !self.inSync.is_empty() {
            os.write_string(2, &self.inSync)?;
        }
        if self.shouldSync != false {
            os.write_bool(3, self.shouldSync)?;
        }
        if !self.divergencePrefix.is_empty() {
            os.write_string(4, &self.divergencePrefix)?;
        }
        if self.divergenceSecondsAgo != 0 {
            os.write_int32(5, self.divergenceSecondsAgo)?;
        }
        if self.theirMessages != 0 {
            os.write_uint64(6, self.theirMessages)?;
        }
        if self.ourMessages != 0 {
            os.write_uint64(7, self.ourMessages)?;
        }
        if self.lastBadSync != 0 {
            os.write_int64(8, self.lastBadSync)?;
        }
        if self.score != 0 {
            os.write_int64(9, self.score)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncStatus {
        SyncStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "peerId",
                |m: &SyncStatus| { &m.peerId },
                |m: &mut SyncStatus| { &mut m.peerId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "inSync",
                |m: &SyncStatus| { &m.inSync },
                |m: &mut SyncStatus| { &mut m.inSync },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "shouldSync",
                |m: &SyncStatus| { &m.shouldSync },
                |m: &mut SyncStatus| { &mut m.shouldSync },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "divergencePrefix",
                |m: &SyncStatus| { &m.divergencePrefix },
                |m: &mut SyncStatus| { &mut m.divergencePrefix },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "divergenceSecondsAgo",
                |m: &SyncStatus| { &m.divergenceSecondsAgo },
                |m: &mut SyncStatus| { &mut m.divergenceSecondsAgo },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "theirMessages",
                |m: &SyncStatus| { &m.theirMessages },
                |m: &mut SyncStatus| { &mut m.theirMessages },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "ourMessages",
                |m: &SyncStatus| { &m.ourMessages },
                |m: &mut SyncStatus| { &mut m.ourMessages },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "lastBadSync",
                |m: &SyncStatus| { &m.lastBadSync },
                |m: &mut SyncStatus| { &mut m.lastBadSync },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "score",
                |m: &SyncStatus| { &m.score },
                |m: &mut SyncStatus| { &mut m.score },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncStatus>(
                "SyncStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncStatus {
        static instance: ::protobuf::rt::LazyV2<SyncStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncStatus::new)
    }
}

impl ::protobuf::Clear for SyncStatus {
    fn clear(&mut self) {
        self.peerId.clear();
        self.inSync.clear();
        self.shouldSync = false;
        self.divergencePrefix.clear();
        self.divergenceSecondsAgo = 0;
        self.theirMessages = 0;
        self.ourMessages = 0;
        self.lastBadSync = 0;
        self.score = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TrieNodeMetadataResponse {
    // message fields
    pub prefix: ::std::vec::Vec<u8>,
    pub num_messages: u64,
    pub hash: ::std::string::String,
    pub children: ::protobuf::RepeatedField<TrieNodeMetadataResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrieNodeMetadataResponse {
    fn default() -> &'a TrieNodeMetadataResponse {
        <TrieNodeMetadataResponse as ::protobuf::Message>::default_instance()
    }
}

impl TrieNodeMetadataResponse {
    pub fn new() -> TrieNodeMetadataResponse {
        ::std::default::Default::default()
    }

    // bytes prefix = 1;


    pub fn get_prefix(&self) -> &[u8] {
        &self.prefix
    }
    pub fn clear_prefix(&mut self) {
        self.prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::vec::Vec<u8>) {
        self.prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.prefix
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.prefix, ::std::vec::Vec::new())
    }

    // uint64 num_messages = 2;


    pub fn get_num_messages(&self) -> u64 {
        self.num_messages
    }
    pub fn clear_num_messages(&mut self) {
        self.num_messages = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_messages(&mut self, v: u64) {
        self.num_messages = v;
    }

    // string hash = 3;


    pub fn get_hash(&self) -> &str {
        &self.hash
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::string::String) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::string::String {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.hash, ::std::string::String::new())
    }

    // repeated .TrieNodeMetadataResponse children = 4;


    pub fn get_children(&self) -> &[TrieNodeMetadataResponse] {
        &self.children
    }
    pub fn clear_children(&mut self) {
        self.children.clear();
    }

    // Param is passed by value, moved
    pub fn set_children(&mut self, v: ::protobuf::RepeatedField<TrieNodeMetadataResponse>) {
        self.children = v;
    }

    // Mutable pointer to the field.
    pub fn mut_children(&mut self) -> &mut ::protobuf::RepeatedField<TrieNodeMetadataResponse> {
        &mut self.children
    }

    // Take field
    pub fn take_children(&mut self) -> ::protobuf::RepeatedField<TrieNodeMetadataResponse> {
        ::std::mem::replace(&mut self.children, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TrieNodeMetadataResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.children {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.prefix)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.num_messages = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.hash)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.children)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.prefix.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.prefix);
        }
        if self.num_messages != 0 {
            my_size += ::protobuf::rt::value_size(2, self.num_messages, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.hash);
        }
        for value in &self.children {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.prefix.is_empty() {
            os.write_bytes(1, &self.prefix)?;
        }
        if self.num_messages != 0 {
            os.write_uint64(2, self.num_messages)?;
        }
        if !self.hash.is_empty() {
            os.write_string(3, &self.hash)?;
        }
        for v in &self.children {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrieNodeMetadataResponse {
        TrieNodeMetadataResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "prefix",
                |m: &TrieNodeMetadataResponse| { &m.prefix },
                |m: &mut TrieNodeMetadataResponse| { &mut m.prefix },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "num_messages",
                |m: &TrieNodeMetadataResponse| { &m.num_messages },
                |m: &mut TrieNodeMetadataResponse| { &mut m.num_messages },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hash",
                |m: &TrieNodeMetadataResponse| { &m.hash },
                |m: &mut TrieNodeMetadataResponse| { &mut m.hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TrieNodeMetadataResponse>>(
                "children",
                |m: &TrieNodeMetadataResponse| { &m.children },
                |m: &mut TrieNodeMetadataResponse| { &mut m.children },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TrieNodeMetadataResponse>(
                "TrieNodeMetadataResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TrieNodeMetadataResponse {
        static instance: ::protobuf::rt::LazyV2<TrieNodeMetadataResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TrieNodeMetadataResponse::new)
    }
}

impl ::protobuf::Clear for TrieNodeMetadataResponse {
    fn clear(&mut self) {
        self.prefix.clear();
        self.num_messages = 0;
        self.hash.clear();
        self.children.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TrieNodeMetadataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrieNodeMetadataResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TrieNodeSnapshotResponse {
    // message fields
    pub prefix: ::std::vec::Vec<u8>,
    pub excluded_hashes: ::protobuf::RepeatedField<::std::string::String>,
    pub num_messages: u64,
    pub root_hash: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrieNodeSnapshotResponse {
    fn default() -> &'a TrieNodeSnapshotResponse {
        <TrieNodeSnapshotResponse as ::protobuf::Message>::default_instance()
    }
}

impl TrieNodeSnapshotResponse {
    pub fn new() -> TrieNodeSnapshotResponse {
        ::std::default::Default::default()
    }

    // bytes prefix = 1;


    pub fn get_prefix(&self) -> &[u8] {
        &self.prefix
    }
    pub fn clear_prefix(&mut self) {
        self.prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::vec::Vec<u8>) {
        self.prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.prefix
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.prefix, ::std::vec::Vec::new())
    }

    // repeated string excluded_hashes = 2;


    pub fn get_excluded_hashes(&self) -> &[::std::string::String] {
        &self.excluded_hashes
    }
    pub fn clear_excluded_hashes(&mut self) {
        self.excluded_hashes.clear();
    }

    // Param is passed by value, moved
    pub fn set_excluded_hashes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.excluded_hashes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_excluded_hashes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.excluded_hashes
    }

    // Take field
    pub fn take_excluded_hashes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.excluded_hashes, ::protobuf::RepeatedField::new())
    }

    // uint64 num_messages = 3;


    pub fn get_num_messages(&self) -> u64 {
        self.num_messages
    }
    pub fn clear_num_messages(&mut self) {
        self.num_messages = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_messages(&mut self, v: u64) {
        self.num_messages = v;
    }

    // string root_hash = 4;


    pub fn get_root_hash(&self) -> &str {
        &self.root_hash
    }
    pub fn clear_root_hash(&mut self) {
        self.root_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_root_hash(&mut self, v: ::std::string::String) {
        self.root_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_root_hash(&mut self) -> &mut ::std::string::String {
        &mut self.root_hash
    }

    // Take field
    pub fn take_root_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.root_hash, ::std::string::String::new())
    }
}

impl ::protobuf::Message for TrieNodeSnapshotResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.prefix)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.excluded_hashes)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.num_messages = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.root_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.prefix.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.prefix);
        }
        for value in &self.excluded_hashes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.num_messages != 0 {
            my_size += ::protobuf::rt::value_size(3, self.num_messages, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.root_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.root_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.prefix.is_empty() {
            os.write_bytes(1, &self.prefix)?;
        }
        for v in &self.excluded_hashes {
            os.write_string(2, &v)?;
        };
        if self.num_messages != 0 {
            os.write_uint64(3, self.num_messages)?;
        }
        if !self.root_hash.is_empty() {
            os.write_string(4, &self.root_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrieNodeSnapshotResponse {
        TrieNodeSnapshotResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "prefix",
                |m: &TrieNodeSnapshotResponse| { &m.prefix },
                |m: &mut TrieNodeSnapshotResponse| { &mut m.prefix },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "excluded_hashes",
                |m: &TrieNodeSnapshotResponse| { &m.excluded_hashes },
                |m: &mut TrieNodeSnapshotResponse| { &mut m.excluded_hashes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "num_messages",
                |m: &TrieNodeSnapshotResponse| { &m.num_messages },
                |m: &mut TrieNodeSnapshotResponse| { &mut m.num_messages },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "root_hash",
                |m: &TrieNodeSnapshotResponse| { &m.root_hash },
                |m: &mut TrieNodeSnapshotResponse| { &mut m.root_hash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TrieNodeSnapshotResponse>(
                "TrieNodeSnapshotResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TrieNodeSnapshotResponse {
        static instance: ::protobuf::rt::LazyV2<TrieNodeSnapshotResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TrieNodeSnapshotResponse::new)
    }
}

impl ::protobuf::Clear for TrieNodeSnapshotResponse {
    fn clear(&mut self) {
        self.prefix.clear();
        self.excluded_hashes.clear();
        self.num_messages = 0;
        self.root_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TrieNodeSnapshotResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrieNodeSnapshotResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TrieNodePrefix {
    // message fields
    pub prefix: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrieNodePrefix {
    fn default() -> &'a TrieNodePrefix {
        <TrieNodePrefix as ::protobuf::Message>::default_instance()
    }
}

impl TrieNodePrefix {
    pub fn new() -> TrieNodePrefix {
        ::std::default::Default::default()
    }

    // bytes prefix = 1;


    pub fn get_prefix(&self) -> &[u8] {
        &self.prefix
    }
    pub fn clear_prefix(&mut self) {
        self.prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::vec::Vec<u8>) {
        self.prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.prefix
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.prefix, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TrieNodePrefix {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.prefix)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.prefix.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.prefix);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.prefix.is_empty() {
            os.write_bytes(1, &self.prefix)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrieNodePrefix {
        TrieNodePrefix::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "prefix",
                |m: &TrieNodePrefix| { &m.prefix },
                |m: &mut TrieNodePrefix| { &mut m.prefix },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TrieNodePrefix>(
                "TrieNodePrefix",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TrieNodePrefix {
        static instance: ::protobuf::rt::LazyV2<TrieNodePrefix> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TrieNodePrefix::new)
    }
}

impl ::protobuf::Clear for TrieNodePrefix {
    fn clear(&mut self) {
        self.prefix.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TrieNodePrefix {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrieNodePrefix {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SyncIds {
    // message fields
    pub sync_ids: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SyncIds {
    fn default() -> &'a SyncIds {
        <SyncIds as ::protobuf::Message>::default_instance()
    }
}

impl SyncIds {
    pub fn new() -> SyncIds {
        ::std::default::Default::default()
    }

    // repeated bytes sync_ids = 1;


    pub fn get_sync_ids(&self) -> &[::std::vec::Vec<u8>] {
        &self.sync_ids
    }
    pub fn clear_sync_ids(&mut self) {
        self.sync_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_sync_ids(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.sync_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sync_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.sync_ids
    }

    // Take field
    pub fn take_sync_ids(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.sync_ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SyncIds {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.sync_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.sync_ids {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.sync_ids {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SyncIds {
        SyncIds::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sync_ids",
                |m: &SyncIds| { &m.sync_ids },
                |m: &mut SyncIds| { &mut m.sync_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SyncIds>(
                "SyncIds",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SyncIds {
        static instance: ::protobuf::rt::LazyV2<SyncIds> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SyncIds::new)
    }
}

impl ::protobuf::Clear for SyncIds {
    fn clear(&mut self) {
        self.sync_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SyncIds {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SyncIds {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FidRequest {
    // message fields
    pub fid: u64,
    pub page_size: u32,
    pub page_token: ::std::vec::Vec<u8>,
    pub reverse: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FidRequest {
    fn default() -> &'a FidRequest {
        <FidRequest as ::protobuf::Message>::default_instance()
    }
}

impl FidRequest {
    pub fn new() -> FidRequest {
        ::std::default::Default::default()
    }

    // uint64 fid = 1;


    pub fn get_fid(&self) -> u64 {
        self.fid
    }
    pub fn clear_fid(&mut self) {
        self.fid = 0;
    }

    // Param is passed by value, moved
    pub fn set_fid(&mut self, v: u64) {
        self.fid = v;
    }

    // uint32 page_size = 2;


    pub fn get_page_size(&self) -> u32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: u32) {
        self.page_size = v;
    }

    // bytes page_token = 3;


    pub fn get_page_token(&self) -> &[u8] {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.page_token, ::std::vec::Vec::new())
    }

    // bool reverse = 4;


    pub fn get_reverse(&self) -> bool {
        self.reverse
    }
    pub fn clear_reverse(&mut self) {
        self.reverse = false;
    }

    // Param is passed by value, moved
    pub fn set_reverse(&mut self, v: bool) {
        self.reverse = v;
    }
}

impl ::protobuf::Message for FidRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fid = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.page_token)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reverse = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.page_token);
        }
        if self.reverse != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if self.page_size != 0 {
            os.write_uint32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_bytes(3, &self.page_token)?;
        }
        if self.reverse != false {
            os.write_bool(4, self.reverse)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FidRequest {
        FidRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fid",
                |m: &FidRequest| { &m.fid },
                |m: &mut FidRequest| { &mut m.fid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page_size",
                |m: &FidRequest| { &m.page_size },
                |m: &mut FidRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "page_token",
                |m: &FidRequest| { &m.page_token },
                |m: &mut FidRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reverse",
                |m: &FidRequest| { &m.reverse },
                |m: &mut FidRequest| { &mut m.reverse },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FidRequest>(
                "FidRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FidRequest {
        static instance: ::protobuf::rt::LazyV2<FidRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FidRequest::new)
    }
}

impl ::protobuf::Clear for FidRequest {
    fn clear(&mut self) {
        self.fid = 0;
        self.page_size = 0;
        self.page_token.clear();
        self.reverse = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FidRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FidRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FidsRequest {
    // message fields
    pub page_size: u32,
    pub page_token: ::std::vec::Vec<u8>,
    pub reverse: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FidsRequest {
    fn default() -> &'a FidsRequest {
        <FidsRequest as ::protobuf::Message>::default_instance()
    }
}

impl FidsRequest {
    pub fn new() -> FidsRequest {
        ::std::default::Default::default()
    }

    // uint32 page_size = 1;


    pub fn get_page_size(&self) -> u32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: u32) {
        self.page_size = v;
    }

    // bytes page_token = 2;


    pub fn get_page_token(&self) -> &[u8] {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.page_token, ::std::vec::Vec::new())
    }

    // bool reverse = 3;


    pub fn get_reverse(&self) -> bool {
        self.reverse
    }
    pub fn clear_reverse(&mut self) {
        self.reverse = false;
    }

    // Param is passed by value, moved
    pub fn set_reverse(&mut self, v: bool) {
        self.reverse = v;
    }
}

impl ::protobuf::Message for FidsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page_size = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.page_token)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reverse = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(1, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.page_token);
        }
        if self.reverse != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.page_size != 0 {
            os.write_uint32(1, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_bytes(2, &self.page_token)?;
        }
        if self.reverse != false {
            os.write_bool(3, self.reverse)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FidsRequest {
        FidsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page_size",
                |m: &FidsRequest| { &m.page_size },
                |m: &mut FidsRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "page_token",
                |m: &FidsRequest| { &m.page_token },
                |m: &mut FidsRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reverse",
                |m: &FidsRequest| { &m.reverse },
                |m: &mut FidsRequest| { &mut m.reverse },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FidsRequest>(
                "FidsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FidsRequest {
        static instance: ::protobuf::rt::LazyV2<FidsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FidsRequest::new)
    }
}

impl ::protobuf::Clear for FidsRequest {
    fn clear(&mut self) {
        self.page_size = 0;
        self.page_token.clear();
        self.reverse = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FidsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FidsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FidsResponse {
    // message fields
    pub fids: ::std::vec::Vec<u64>,
    pub next_page_token: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FidsResponse {
    fn default() -> &'a FidsResponse {
        <FidsResponse as ::protobuf::Message>::default_instance()
    }
}

impl FidsResponse {
    pub fn new() -> FidsResponse {
        ::std::default::Default::default()
    }

    // repeated uint64 fids = 1;


    pub fn get_fids(&self) -> &[u64] {
        &self.fids
    }
    pub fn clear_fids(&mut self) {
        self.fids.clear();
    }

    // Param is passed by value, moved
    pub fn set_fids(&mut self, v: ::std::vec::Vec<u64>) {
        self.fids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.fids
    }

    // Take field
    pub fn take_fids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.fids, ::std::vec::Vec::new())
    }

    // bytes next_page_token = 2;


    pub fn get_next_page_token(&self) -> &[u8] {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.next_page_token, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for FidsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.fids)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.fids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.fids {
            os.write_uint64(1, *v)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_bytes(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FidsResponse {
        FidsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fids",
                |m: &FidsResponse| { &m.fids },
                |m: &mut FidsResponse| { &mut m.fids },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "next_page_token",
                |m: &FidsResponse| { &m.next_page_token },
                |m: &mut FidsResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FidsResponse>(
                "FidsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FidsResponse {
        static instance: ::protobuf::rt::LazyV2<FidsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FidsResponse::new)
    }
}

impl ::protobuf::Clear for FidsResponse {
    fn clear(&mut self) {
        self.fids.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FidsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FidsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessagesResponse {
    // message fields
    pub messages: ::protobuf::RepeatedField<super::message::Message>,
    pub next_page_token: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessagesResponse {
    fn default() -> &'a MessagesResponse {
        <MessagesResponse as ::protobuf::Message>::default_instance()
    }
}

impl MessagesResponse {
    pub fn new() -> MessagesResponse {
        ::std::default::Default::default()
    }

    // repeated .Message messages = 1;


    pub fn get_messages(&self) -> &[super::message::Message] {
        &self.messages
    }
    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::protobuf::RepeatedField<super::message::Message>) {
        self.messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_messages(&mut self) -> &mut ::protobuf::RepeatedField<super::message::Message> {
        &mut self.messages
    }

    // Take field
    pub fn take_messages(&mut self) -> ::protobuf::RepeatedField<super::message::Message> {
        ::std::mem::replace(&mut self.messages, ::protobuf::RepeatedField::new())
    }

    // bytes next_page_token = 2;


    pub fn get_next_page_token(&self) -> &[u8] {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.next_page_token, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MessagesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.messages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.messages)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.messages {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_bytes(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessagesResponse {
        MessagesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::message::Message>>(
                "messages",
                |m: &MessagesResponse| { &m.messages },
                |m: &mut MessagesResponse| { &mut m.messages },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "next_page_token",
                |m: &MessagesResponse| { &m.next_page_token },
                |m: &mut MessagesResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MessagesResponse>(
                "MessagesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MessagesResponse {
        static instance: ::protobuf::rt::LazyV2<MessagesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MessagesResponse::new)
    }
}

impl ::protobuf::Clear for MessagesResponse {
    fn clear(&mut self) {
        self.messages.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessagesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessagesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CastsByParentRequest {
    // message fields
    pub page_size: u32,
    pub page_token: ::std::vec::Vec<u8>,
    pub reverse: bool,
    // message oneof groups
    pub parent: ::std::option::Option<CastsByParentRequest_oneof_parent>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CastsByParentRequest {
    fn default() -> &'a CastsByParentRequest {
        <CastsByParentRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum CastsByParentRequest_oneof_parent {
    parent_cast_id(super::message::CastId),
    parent_url(::std::string::String),
}

impl CastsByParentRequest {
    pub fn new() -> CastsByParentRequest {
        ::std::default::Default::default()
    }

    // .CastId parent_cast_id = 1;


    pub fn get_parent_cast_id(&self) -> &super::message::CastId {
        match self.parent {
            ::std::option::Option::Some(CastsByParentRequest_oneof_parent::parent_cast_id(ref v)) => v,
            _ => <super::message::CastId as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_parent_cast_id(&mut self) {
        self.parent = ::std::option::Option::None;
    }

    pub fn has_parent_cast_id(&self) -> bool {
        match self.parent {
            ::std::option::Option::Some(CastsByParentRequest_oneof_parent::parent_cast_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_parent_cast_id(&mut self, v: super::message::CastId) {
        self.parent = ::std::option::Option::Some(CastsByParentRequest_oneof_parent::parent_cast_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_parent_cast_id(&mut self) -> &mut super::message::CastId {
        if let ::std::option::Option::Some(CastsByParentRequest_oneof_parent::parent_cast_id(_)) = self.parent {
        } else {
            self.parent = ::std::option::Option::Some(CastsByParentRequest_oneof_parent::parent_cast_id(super::message::CastId::new()));
        }
        match self.parent {
            ::std::option::Option::Some(CastsByParentRequest_oneof_parent::parent_cast_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_parent_cast_id(&mut self) -> super::message::CastId {
        if self.has_parent_cast_id() {
            match self.parent.take() {
                ::std::option::Option::Some(CastsByParentRequest_oneof_parent::parent_cast_id(v)) => v,
                _ => panic!(),
            }
        } else {
            super::message::CastId::new()
        }
    }

    // string parent_url = 5;


    pub fn get_parent_url(&self) -> &str {
        match self.parent {
            ::std::option::Option::Some(CastsByParentRequest_oneof_parent::parent_url(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_parent_url(&mut self) {
        self.parent = ::std::option::Option::None;
    }

    pub fn has_parent_url(&self) -> bool {
        match self.parent {
            ::std::option::Option::Some(CastsByParentRequest_oneof_parent::parent_url(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_parent_url(&mut self, v: ::std::string::String) {
        self.parent = ::std::option::Option::Some(CastsByParentRequest_oneof_parent::parent_url(v))
    }

    // Mutable pointer to the field.
    pub fn mut_parent_url(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(CastsByParentRequest_oneof_parent::parent_url(_)) = self.parent {
        } else {
            self.parent = ::std::option::Option::Some(CastsByParentRequest_oneof_parent::parent_url(::std::string::String::new()));
        }
        match self.parent {
            ::std::option::Option::Some(CastsByParentRequest_oneof_parent::parent_url(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_parent_url(&mut self) -> ::std::string::String {
        if self.has_parent_url() {
            match self.parent.take() {
                ::std::option::Option::Some(CastsByParentRequest_oneof_parent::parent_url(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // uint32 page_size = 2;


    pub fn get_page_size(&self) -> u32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: u32) {
        self.page_size = v;
    }

    // bytes page_token = 3;


    pub fn get_page_token(&self) -> &[u8] {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.page_token, ::std::vec::Vec::new())
    }

    // bool reverse = 4;


    pub fn get_reverse(&self) -> bool {
        self.reverse
    }
    pub fn clear_reverse(&mut self) {
        self.reverse = false;
    }

    // Param is passed by value, moved
    pub fn set_reverse(&mut self, v: bool) {
        self.reverse = v;
    }
}

impl ::protobuf::Message for CastsByParentRequest {
    fn is_initialized(&self) -> bool {
        if let Some(CastsByParentRequest_oneof_parent::parent_cast_id(ref v)) = self.parent {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.parent = ::std::option::Option::Some(CastsByParentRequest_oneof_parent::parent_cast_id(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.parent = ::std::option::Option::Some(CastsByParentRequest_oneof_parent::parent_url(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.page_token)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reverse = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.page_token);
        }
        if self.reverse != false {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.parent {
            match v {
                &CastsByParentRequest_oneof_parent::parent_cast_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CastsByParentRequest_oneof_parent::parent_url(ref v) => {
                    my_size += ::protobuf::rt::string_size(5, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.page_size != 0 {
            os.write_uint32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_bytes(3, &self.page_token)?;
        }
        if self.reverse != false {
            os.write_bool(4, self.reverse)?;
        }
        if let ::std::option::Option::Some(ref v) = self.parent {
            match v {
                &CastsByParentRequest_oneof_parent::parent_cast_id(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CastsByParentRequest_oneof_parent::parent_url(ref v) => {
                    os.write_string(5, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CastsByParentRequest {
        CastsByParentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::message::CastId>(
                "parent_cast_id",
                CastsByParentRequest::has_parent_cast_id,
                CastsByParentRequest::get_parent_cast_id,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "parent_url",
                CastsByParentRequest::has_parent_url,
                CastsByParentRequest::get_parent_url,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page_size",
                |m: &CastsByParentRequest| { &m.page_size },
                |m: &mut CastsByParentRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "page_token",
                |m: &CastsByParentRequest| { &m.page_token },
                |m: &mut CastsByParentRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reverse",
                |m: &CastsByParentRequest| { &m.reverse },
                |m: &mut CastsByParentRequest| { &mut m.reverse },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CastsByParentRequest>(
                "CastsByParentRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CastsByParentRequest {
        static instance: ::protobuf::rt::LazyV2<CastsByParentRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CastsByParentRequest::new)
    }
}

impl ::protobuf::Clear for CastsByParentRequest {
    fn clear(&mut self) {
        self.parent = ::std::option::Option::None;
        self.parent = ::std::option::Option::None;
        self.page_size = 0;
        self.page_token.clear();
        self.reverse = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CastsByParentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CastsByParentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReactionRequest {
    // message fields
    pub fid: u64,
    pub reaction_type: super::message::ReactionType,
    // message oneof groups
    pub target: ::std::option::Option<ReactionRequest_oneof_target>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReactionRequest {
    fn default() -> &'a ReactionRequest {
        <ReactionRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ReactionRequest_oneof_target {
    target_cast_id(super::message::CastId),
    target_url(::std::string::String),
}

impl ReactionRequest {
    pub fn new() -> ReactionRequest {
        ::std::default::Default::default()
    }

    // uint64 fid = 1;


    pub fn get_fid(&self) -> u64 {
        self.fid
    }
    pub fn clear_fid(&mut self) {
        self.fid = 0;
    }

    // Param is passed by value, moved
    pub fn set_fid(&mut self, v: u64) {
        self.fid = v;
    }

    // .ReactionType reaction_type = 2;


    pub fn get_reaction_type(&self) -> super::message::ReactionType {
        self.reaction_type
    }
    pub fn clear_reaction_type(&mut self) {
        self.reaction_type = super::message::ReactionType::REACTION_TYPE_NONE;
    }

    // Param is passed by value, moved
    pub fn set_reaction_type(&mut self, v: super::message::ReactionType) {
        self.reaction_type = v;
    }

    // .CastId target_cast_id = 3;


    pub fn get_target_cast_id(&self) -> &super::message::CastId {
        match self.target {
            ::std::option::Option::Some(ReactionRequest_oneof_target::target_cast_id(ref v)) => v,
            _ => <super::message::CastId as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_target_cast_id(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target_cast_id(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(ReactionRequest_oneof_target::target_cast_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_target_cast_id(&mut self, v: super::message::CastId) {
        self.target = ::std::option::Option::Some(ReactionRequest_oneof_target::target_cast_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_target_cast_id(&mut self) -> &mut super::message::CastId {
        if let ::std::option::Option::Some(ReactionRequest_oneof_target::target_cast_id(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(ReactionRequest_oneof_target::target_cast_id(super::message::CastId::new()));
        }
        match self.target {
            ::std::option::Option::Some(ReactionRequest_oneof_target::target_cast_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_target_cast_id(&mut self) -> super::message::CastId {
        if self.has_target_cast_id() {
            match self.target.take() {
                ::std::option::Option::Some(ReactionRequest_oneof_target::target_cast_id(v)) => v,
                _ => panic!(),
            }
        } else {
            super::message::CastId::new()
        }
    }

    // string target_url = 4;


    pub fn get_target_url(&self) -> &str {
        match self.target {
            ::std::option::Option::Some(ReactionRequest_oneof_target::target_url(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_target_url(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target_url(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(ReactionRequest_oneof_target::target_url(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_target_url(&mut self, v: ::std::string::String) {
        self.target = ::std::option::Option::Some(ReactionRequest_oneof_target::target_url(v))
    }

    // Mutable pointer to the field.
    pub fn mut_target_url(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(ReactionRequest_oneof_target::target_url(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(ReactionRequest_oneof_target::target_url(::std::string::String::new()));
        }
        match self.target {
            ::std::option::Option::Some(ReactionRequest_oneof_target::target_url(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_target_url(&mut self) -> ::std::string::String {
        if self.has_target_url() {
            match self.target.take() {
                ::std::option::Option::Some(ReactionRequest_oneof_target::target_url(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for ReactionRequest {
    fn is_initialized(&self) -> bool {
        if let Some(ReactionRequest_oneof_target::target_cast_id(ref v)) = self.target {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fid = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.reaction_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target = ::std::option::Option::Some(ReactionRequest_oneof_target::target_cast_id(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target = ::std::option::Option::Some(ReactionRequest_oneof_target::target_url(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.reaction_type != super::message::ReactionType::REACTION_TYPE_NONE {
            my_size += ::protobuf::rt::enum_size(2, self.reaction_type);
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &ReactionRequest_oneof_target::target_cast_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ReactionRequest_oneof_target::target_url(ref v) => {
                    my_size += ::protobuf::rt::string_size(4, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if self.reaction_type != super::message::ReactionType::REACTION_TYPE_NONE {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.reaction_type))?;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &ReactionRequest_oneof_target::target_cast_id(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ReactionRequest_oneof_target::target_url(ref v) => {
                    os.write_string(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReactionRequest {
        ReactionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fid",
                |m: &ReactionRequest| { &m.fid },
                |m: &mut ReactionRequest| { &mut m.fid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::message::ReactionType>>(
                "reaction_type",
                |m: &ReactionRequest| { &m.reaction_type },
                |m: &mut ReactionRequest| { &mut m.reaction_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::message::CastId>(
                "target_cast_id",
                ReactionRequest::has_target_cast_id,
                ReactionRequest::get_target_cast_id,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "target_url",
                ReactionRequest::has_target_url,
                ReactionRequest::get_target_url,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReactionRequest>(
                "ReactionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReactionRequest {
        static instance: ::protobuf::rt::LazyV2<ReactionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReactionRequest::new)
    }
}

impl ::protobuf::Clear for ReactionRequest {
    fn clear(&mut self) {
        self.fid = 0;
        self.reaction_type = super::message::ReactionType::REACTION_TYPE_NONE;
        self.target = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReactionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReactionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReactionsByFidRequest {
    // message fields
    pub fid: u64,
    pub reaction_type: super::message::ReactionType,
    pub page_size: u32,
    pub page_token: ::std::vec::Vec<u8>,
    pub reverse: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReactionsByFidRequest {
    fn default() -> &'a ReactionsByFidRequest {
        <ReactionsByFidRequest as ::protobuf::Message>::default_instance()
    }
}

impl ReactionsByFidRequest {
    pub fn new() -> ReactionsByFidRequest {
        ::std::default::Default::default()
    }

    // uint64 fid = 1;


    pub fn get_fid(&self) -> u64 {
        self.fid
    }
    pub fn clear_fid(&mut self) {
        self.fid = 0;
    }

    // Param is passed by value, moved
    pub fn set_fid(&mut self, v: u64) {
        self.fid = v;
    }

    // .ReactionType reaction_type = 2;


    pub fn get_reaction_type(&self) -> super::message::ReactionType {
        self.reaction_type
    }
    pub fn clear_reaction_type(&mut self) {
        self.reaction_type = super::message::ReactionType::REACTION_TYPE_NONE;
    }

    // Param is passed by value, moved
    pub fn set_reaction_type(&mut self, v: super::message::ReactionType) {
        self.reaction_type = v;
    }

    // uint32 page_size = 3;


    pub fn get_page_size(&self) -> u32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: u32) {
        self.page_size = v;
    }

    // bytes page_token = 4;


    pub fn get_page_token(&self) -> &[u8] {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.page_token, ::std::vec::Vec::new())
    }

    // bool reverse = 5;


    pub fn get_reverse(&self) -> bool {
        self.reverse
    }
    pub fn clear_reverse(&mut self) {
        self.reverse = false;
    }

    // Param is passed by value, moved
    pub fn set_reverse(&mut self, v: bool) {
        self.reverse = v;
    }
}

impl ::protobuf::Message for ReactionsByFidRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fid = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.reaction_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page_size = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.page_token)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reverse = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.reaction_type != super::message::ReactionType::REACTION_TYPE_NONE {
            my_size += ::protobuf::rt::enum_size(2, self.reaction_type);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.page_token);
        }
        if self.reverse != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if self.reaction_type != super::message::ReactionType::REACTION_TYPE_NONE {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.reaction_type))?;
        }
        if self.page_size != 0 {
            os.write_uint32(3, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_bytes(4, &self.page_token)?;
        }
        if self.reverse != false {
            os.write_bool(5, self.reverse)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReactionsByFidRequest {
        ReactionsByFidRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fid",
                |m: &ReactionsByFidRequest| { &m.fid },
                |m: &mut ReactionsByFidRequest| { &mut m.fid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::message::ReactionType>>(
                "reaction_type",
                |m: &ReactionsByFidRequest| { &m.reaction_type },
                |m: &mut ReactionsByFidRequest| { &mut m.reaction_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page_size",
                |m: &ReactionsByFidRequest| { &m.page_size },
                |m: &mut ReactionsByFidRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "page_token",
                |m: &ReactionsByFidRequest| { &m.page_token },
                |m: &mut ReactionsByFidRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reverse",
                |m: &ReactionsByFidRequest| { &m.reverse },
                |m: &mut ReactionsByFidRequest| { &mut m.reverse },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReactionsByFidRequest>(
                "ReactionsByFidRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReactionsByFidRequest {
        static instance: ::protobuf::rt::LazyV2<ReactionsByFidRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReactionsByFidRequest::new)
    }
}

impl ::protobuf::Clear for ReactionsByFidRequest {
    fn clear(&mut self) {
        self.fid = 0;
        self.reaction_type = super::message::ReactionType::REACTION_TYPE_NONE;
        self.page_size = 0;
        self.page_token.clear();
        self.reverse = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReactionsByFidRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReactionsByFidRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReactionsByTargetRequest {
    // message fields
    pub reaction_type: super::message::ReactionType,
    pub page_size: u32,
    pub page_token: ::std::vec::Vec<u8>,
    pub reverse: bool,
    // message oneof groups
    pub target: ::std::option::Option<ReactionsByTargetRequest_oneof_target>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReactionsByTargetRequest {
    fn default() -> &'a ReactionsByTargetRequest {
        <ReactionsByTargetRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ReactionsByTargetRequest_oneof_target {
    target_cast_id(super::message::CastId),
    target_url(::std::string::String),
}

impl ReactionsByTargetRequest {
    pub fn new() -> ReactionsByTargetRequest {
        ::std::default::Default::default()
    }

    // .CastId target_cast_id = 1;


    pub fn get_target_cast_id(&self) -> &super::message::CastId {
        match self.target {
            ::std::option::Option::Some(ReactionsByTargetRequest_oneof_target::target_cast_id(ref v)) => v,
            _ => <super::message::CastId as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_target_cast_id(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target_cast_id(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(ReactionsByTargetRequest_oneof_target::target_cast_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_target_cast_id(&mut self, v: super::message::CastId) {
        self.target = ::std::option::Option::Some(ReactionsByTargetRequest_oneof_target::target_cast_id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_target_cast_id(&mut self) -> &mut super::message::CastId {
        if let ::std::option::Option::Some(ReactionsByTargetRequest_oneof_target::target_cast_id(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(ReactionsByTargetRequest_oneof_target::target_cast_id(super::message::CastId::new()));
        }
        match self.target {
            ::std::option::Option::Some(ReactionsByTargetRequest_oneof_target::target_cast_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_target_cast_id(&mut self) -> super::message::CastId {
        if self.has_target_cast_id() {
            match self.target.take() {
                ::std::option::Option::Some(ReactionsByTargetRequest_oneof_target::target_cast_id(v)) => v,
                _ => panic!(),
            }
        } else {
            super::message::CastId::new()
        }
    }

    // string target_url = 6;


    pub fn get_target_url(&self) -> &str {
        match self.target {
            ::std::option::Option::Some(ReactionsByTargetRequest_oneof_target::target_url(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_target_url(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target_url(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(ReactionsByTargetRequest_oneof_target::target_url(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_target_url(&mut self, v: ::std::string::String) {
        self.target = ::std::option::Option::Some(ReactionsByTargetRequest_oneof_target::target_url(v))
    }

    // Mutable pointer to the field.
    pub fn mut_target_url(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(ReactionsByTargetRequest_oneof_target::target_url(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(ReactionsByTargetRequest_oneof_target::target_url(::std::string::String::new()));
        }
        match self.target {
            ::std::option::Option::Some(ReactionsByTargetRequest_oneof_target::target_url(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_target_url(&mut self) -> ::std::string::String {
        if self.has_target_url() {
            match self.target.take() {
                ::std::option::Option::Some(ReactionsByTargetRequest_oneof_target::target_url(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .ReactionType reaction_type = 2;


    pub fn get_reaction_type(&self) -> super::message::ReactionType {
        self.reaction_type
    }
    pub fn clear_reaction_type(&mut self) {
        self.reaction_type = super::message::ReactionType::REACTION_TYPE_NONE;
    }

    // Param is passed by value, moved
    pub fn set_reaction_type(&mut self, v: super::message::ReactionType) {
        self.reaction_type = v;
    }

    // uint32 page_size = 3;


    pub fn get_page_size(&self) -> u32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: u32) {
        self.page_size = v;
    }

    // bytes page_token = 4;


    pub fn get_page_token(&self) -> &[u8] {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.page_token, ::std::vec::Vec::new())
    }

    // bool reverse = 5;


    pub fn get_reverse(&self) -> bool {
        self.reverse
    }
    pub fn clear_reverse(&mut self) {
        self.reverse = false;
    }

    // Param is passed by value, moved
    pub fn set_reverse(&mut self, v: bool) {
        self.reverse = v;
    }
}

impl ::protobuf::Message for ReactionsByTargetRequest {
    fn is_initialized(&self) -> bool {
        if let Some(ReactionsByTargetRequest_oneof_target::target_cast_id(ref v)) = self.target {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target = ::std::option::Option::Some(ReactionsByTargetRequest_oneof_target::target_cast_id(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target = ::std::option::Option::Some(ReactionsByTargetRequest_oneof_target::target_url(is.read_string()?));
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.reaction_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page_size = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.page_token)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reverse = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.reaction_type != super::message::ReactionType::REACTION_TYPE_NONE {
            my_size += ::protobuf::rt::enum_size(2, self.reaction_type);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.page_token);
        }
        if self.reverse != false {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &ReactionsByTargetRequest_oneof_target::target_cast_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ReactionsByTargetRequest_oneof_target::target_url(ref v) => {
                    my_size += ::protobuf::rt::string_size(6, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.reaction_type != super::message::ReactionType::REACTION_TYPE_NONE {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.reaction_type))?;
        }
        if self.page_size != 0 {
            os.write_uint32(3, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_bytes(4, &self.page_token)?;
        }
        if self.reverse != false {
            os.write_bool(5, self.reverse)?;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &ReactionsByTargetRequest_oneof_target::target_cast_id(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ReactionsByTargetRequest_oneof_target::target_url(ref v) => {
                    os.write_string(6, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReactionsByTargetRequest {
        ReactionsByTargetRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::message::CastId>(
                "target_cast_id",
                ReactionsByTargetRequest::has_target_cast_id,
                ReactionsByTargetRequest::get_target_cast_id,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "target_url",
                ReactionsByTargetRequest::has_target_url,
                ReactionsByTargetRequest::get_target_url,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::message::ReactionType>>(
                "reaction_type",
                |m: &ReactionsByTargetRequest| { &m.reaction_type },
                |m: &mut ReactionsByTargetRequest| { &mut m.reaction_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page_size",
                |m: &ReactionsByTargetRequest| { &m.page_size },
                |m: &mut ReactionsByTargetRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "page_token",
                |m: &ReactionsByTargetRequest| { &m.page_token },
                |m: &mut ReactionsByTargetRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reverse",
                |m: &ReactionsByTargetRequest| { &m.reverse },
                |m: &mut ReactionsByTargetRequest| { &mut m.reverse },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReactionsByTargetRequest>(
                "ReactionsByTargetRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReactionsByTargetRequest {
        static instance: ::protobuf::rt::LazyV2<ReactionsByTargetRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReactionsByTargetRequest::new)
    }
}

impl ::protobuf::Clear for ReactionsByTargetRequest {
    fn clear(&mut self) {
        self.target = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.reaction_type = super::message::ReactionType::REACTION_TYPE_NONE;
        self.page_size = 0;
        self.page_token.clear();
        self.reverse = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReactionsByTargetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReactionsByTargetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserDataRequest {
    // message fields
    pub fid: u64,
    pub user_data_type: super::message::UserDataType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserDataRequest {
    fn default() -> &'a UserDataRequest {
        <UserDataRequest as ::protobuf::Message>::default_instance()
    }
}

impl UserDataRequest {
    pub fn new() -> UserDataRequest {
        ::std::default::Default::default()
    }

    // uint64 fid = 1;


    pub fn get_fid(&self) -> u64 {
        self.fid
    }
    pub fn clear_fid(&mut self) {
        self.fid = 0;
    }

    // Param is passed by value, moved
    pub fn set_fid(&mut self, v: u64) {
        self.fid = v;
    }

    // .UserDataType user_data_type = 2;


    pub fn get_user_data_type(&self) -> super::message::UserDataType {
        self.user_data_type
    }
    pub fn clear_user_data_type(&mut self) {
        self.user_data_type = super::message::UserDataType::USER_DATA_TYPE_NONE;
    }

    // Param is passed by value, moved
    pub fn set_user_data_type(&mut self, v: super::message::UserDataType) {
        self.user_data_type = v;
    }
}

impl ::protobuf::Message for UserDataRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fid = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.user_data_type, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.user_data_type != super::message::UserDataType::USER_DATA_TYPE_NONE {
            my_size += ::protobuf::rt::enum_size(2, self.user_data_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if self.user_data_type != super::message::UserDataType::USER_DATA_TYPE_NONE {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.user_data_type))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserDataRequest {
        UserDataRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fid",
                |m: &UserDataRequest| { &m.fid },
                |m: &mut UserDataRequest| { &mut m.fid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::message::UserDataType>>(
                "user_data_type",
                |m: &UserDataRequest| { &m.user_data_type },
                |m: &mut UserDataRequest| { &mut m.user_data_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserDataRequest>(
                "UserDataRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UserDataRequest {
        static instance: ::protobuf::rt::LazyV2<UserDataRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UserDataRequest::new)
    }
}

impl ::protobuf::Clear for UserDataRequest {
    fn clear(&mut self) {
        self.fid = 0;
        self.user_data_type = super::message::UserDataType::USER_DATA_TYPE_NONE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserDataRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserDataRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NameRegistryEventRequest {
    // message fields
    pub name: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NameRegistryEventRequest {
    fn default() -> &'a NameRegistryEventRequest {
        <NameRegistryEventRequest as ::protobuf::Message>::default_instance()
    }
}

impl NameRegistryEventRequest {
    pub fn new() -> NameRegistryEventRequest {
        ::std::default::Default::default()
    }

    // bytes name = 1;


    pub fn get_name(&self) -> &[u8] {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::vec::Vec<u8>) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.name, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for NameRegistryEventRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_bytes(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NameRegistryEventRequest {
        NameRegistryEventRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "name",
                |m: &NameRegistryEventRequest| { &m.name },
                |m: &mut NameRegistryEventRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NameRegistryEventRequest>(
                "NameRegistryEventRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NameRegistryEventRequest {
        static instance: ::protobuf::rt::LazyV2<NameRegistryEventRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NameRegistryEventRequest::new)
    }
}

impl ::protobuf::Clear for NameRegistryEventRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NameRegistryEventRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NameRegistryEventRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RentRegistryEventsRequest {
    // message fields
    pub fid: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RentRegistryEventsRequest {
    fn default() -> &'a RentRegistryEventsRequest {
        <RentRegistryEventsRequest as ::protobuf::Message>::default_instance()
    }
}

impl RentRegistryEventsRequest {
    pub fn new() -> RentRegistryEventsRequest {
        ::std::default::Default::default()
    }

    // uint64 fid = 1;


    pub fn get_fid(&self) -> u64 {
        self.fid
    }
    pub fn clear_fid(&mut self) {
        self.fid = 0;
    }

    // Param is passed by value, moved
    pub fn set_fid(&mut self, v: u64) {
        self.fid = v;
    }
}

impl ::protobuf::Message for RentRegistryEventsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fid = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fid, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RentRegistryEventsRequest {
        RentRegistryEventsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fid",
                |m: &RentRegistryEventsRequest| { &m.fid },
                |m: &mut RentRegistryEventsRequest| { &mut m.fid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RentRegistryEventsRequest>(
                "RentRegistryEventsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RentRegistryEventsRequest {
        static instance: ::protobuf::rt::LazyV2<RentRegistryEventsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RentRegistryEventsRequest::new)
    }
}

impl ::protobuf::Clear for RentRegistryEventsRequest {
    fn clear(&mut self) {
        self.fid = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RentRegistryEventsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RentRegistryEventsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OnChainEventRequest {
    // message fields
    pub fid: u64,
    pub event_type: super::onchain_event::OnChainEventType,
    pub page_size: u32,
    pub page_token: ::std::vec::Vec<u8>,
    pub reverse: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OnChainEventRequest {
    fn default() -> &'a OnChainEventRequest {
        <OnChainEventRequest as ::protobuf::Message>::default_instance()
    }
}

impl OnChainEventRequest {
    pub fn new() -> OnChainEventRequest {
        ::std::default::Default::default()
    }

    // uint64 fid = 1;


    pub fn get_fid(&self) -> u64 {
        self.fid
    }
    pub fn clear_fid(&mut self) {
        self.fid = 0;
    }

    // Param is passed by value, moved
    pub fn set_fid(&mut self, v: u64) {
        self.fid = v;
    }

    // .OnChainEventType event_type = 2;


    pub fn get_event_type(&self) -> super::onchain_event::OnChainEventType {
        self.event_type
    }
    pub fn clear_event_type(&mut self) {
        self.event_type = super::onchain_event::OnChainEventType::EVENT_TYPE_NONE;
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: super::onchain_event::OnChainEventType) {
        self.event_type = v;
    }

    // uint32 page_size = 3;


    pub fn get_page_size(&self) -> u32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: u32) {
        self.page_size = v;
    }

    // bytes page_token = 4;


    pub fn get_page_token(&self) -> &[u8] {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.page_token, ::std::vec::Vec::new())
    }

    // bool reverse = 5;


    pub fn get_reverse(&self) -> bool {
        self.reverse
    }
    pub fn clear_reverse(&mut self) {
        self.reverse = false;
    }

    // Param is passed by value, moved
    pub fn set_reverse(&mut self, v: bool) {
        self.reverse = v;
    }
}

impl ::protobuf::Message for OnChainEventRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fid = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.event_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page_size = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.page_token)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reverse = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.event_type != super::onchain_event::OnChainEventType::EVENT_TYPE_NONE {
            my_size += ::protobuf::rt::enum_size(2, self.event_type);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.page_token);
        }
        if self.reverse != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if self.event_type != super::onchain_event::OnChainEventType::EVENT_TYPE_NONE {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.event_type))?;
        }
        if self.page_size != 0 {
            os.write_uint32(3, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_bytes(4, &self.page_token)?;
        }
        if self.reverse != false {
            os.write_bool(5, self.reverse)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OnChainEventRequest {
        OnChainEventRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fid",
                |m: &OnChainEventRequest| { &m.fid },
                |m: &mut OnChainEventRequest| { &mut m.fid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::onchain_event::OnChainEventType>>(
                "event_type",
                |m: &OnChainEventRequest| { &m.event_type },
                |m: &mut OnChainEventRequest| { &mut m.event_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page_size",
                |m: &OnChainEventRequest| { &m.page_size },
                |m: &mut OnChainEventRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "page_token",
                |m: &OnChainEventRequest| { &m.page_token },
                |m: &mut OnChainEventRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reverse",
                |m: &OnChainEventRequest| { &m.reverse },
                |m: &mut OnChainEventRequest| { &mut m.reverse },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OnChainEventRequest>(
                "OnChainEventRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OnChainEventRequest {
        static instance: ::protobuf::rt::LazyV2<OnChainEventRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OnChainEventRequest::new)
    }
}

impl ::protobuf::Clear for OnChainEventRequest {
    fn clear(&mut self) {
        self.fid = 0;
        self.event_type = super::onchain_event::OnChainEventType::EVENT_TYPE_NONE;
        self.page_size = 0;
        self.page_token.clear();
        self.reverse = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OnChainEventRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OnChainEventRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OnChainEventResponse {
    // message fields
    pub events: ::protobuf::RepeatedField<super::onchain_event::OnChainEvent>,
    pub next_page_token: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OnChainEventResponse {
    fn default() -> &'a OnChainEventResponse {
        <OnChainEventResponse as ::protobuf::Message>::default_instance()
    }
}

impl OnChainEventResponse {
    pub fn new() -> OnChainEventResponse {
        ::std::default::Default::default()
    }

    // repeated .OnChainEvent events = 1;


    pub fn get_events(&self) -> &[super::onchain_event::OnChainEvent] {
        &self.events
    }
    pub fn clear_events(&mut self) {
        self.events.clear();
    }

    // Param is passed by value, moved
    pub fn set_events(&mut self, v: ::protobuf::RepeatedField<super::onchain_event::OnChainEvent>) {
        self.events = v;
    }

    // Mutable pointer to the field.
    pub fn mut_events(&mut self) -> &mut ::protobuf::RepeatedField<super::onchain_event::OnChainEvent> {
        &mut self.events
    }

    // Take field
    pub fn take_events(&mut self) -> ::protobuf::RepeatedField<super::onchain_event::OnChainEvent> {
        ::std::mem::replace(&mut self.events, ::protobuf::RepeatedField::new())
    }

    // bytes next_page_token = 2;


    pub fn get_next_page_token(&self) -> &[u8] {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.next_page_token, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for OnChainEventResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.events {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.events)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.events {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_bytes(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OnChainEventResponse {
        OnChainEventResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::onchain_event::OnChainEvent>>(
                "events",
                |m: &OnChainEventResponse| { &m.events },
                |m: &mut OnChainEventResponse| { &mut m.events },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "next_page_token",
                |m: &OnChainEventResponse| { &m.next_page_token },
                |m: &mut OnChainEventResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OnChainEventResponse>(
                "OnChainEventResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OnChainEventResponse {
        static instance: ::protobuf::rt::LazyV2<OnChainEventResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OnChainEventResponse::new)
    }
}

impl ::protobuf::Clear for OnChainEventResponse {
    fn clear(&mut self) {
        self.events.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OnChainEventResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OnChainEventResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StorageLimitsResponse {
    // message fields
    pub limits: ::protobuf::RepeatedField<StorageLimit>,
    pub units: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StorageLimitsResponse {
    fn default() -> &'a StorageLimitsResponse {
        <StorageLimitsResponse as ::protobuf::Message>::default_instance()
    }
}

impl StorageLimitsResponse {
    pub fn new() -> StorageLimitsResponse {
        ::std::default::Default::default()
    }

    // repeated .StorageLimit limits = 1;


    pub fn get_limits(&self) -> &[StorageLimit] {
        &self.limits
    }
    pub fn clear_limits(&mut self) {
        self.limits.clear();
    }

    // Param is passed by value, moved
    pub fn set_limits(&mut self, v: ::protobuf::RepeatedField<StorageLimit>) {
        self.limits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_limits(&mut self) -> &mut ::protobuf::RepeatedField<StorageLimit> {
        &mut self.limits
    }

    // Take field
    pub fn take_limits(&mut self) -> ::protobuf::RepeatedField<StorageLimit> {
        ::std::mem::replace(&mut self.limits, ::protobuf::RepeatedField::new())
    }

    // uint32 units = 2;


    pub fn get_units(&self) -> u32 {
        self.units
    }
    pub fn clear_units(&mut self) {
        self.units = 0;
    }

    // Param is passed by value, moved
    pub fn set_units(&mut self, v: u32) {
        self.units = v;
    }
}

impl ::protobuf::Message for StorageLimitsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.limits {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.limits)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.units = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.limits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.units != 0 {
            my_size += ::protobuf::rt::value_size(2, self.units, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.limits {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.units != 0 {
            os.write_uint32(2, self.units)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StorageLimitsResponse {
        StorageLimitsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StorageLimit>>(
                "limits",
                |m: &StorageLimitsResponse| { &m.limits },
                |m: &mut StorageLimitsResponse| { &mut m.limits },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "units",
                |m: &StorageLimitsResponse| { &m.units },
                |m: &mut StorageLimitsResponse| { &mut m.units },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StorageLimitsResponse>(
                "StorageLimitsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StorageLimitsResponse {
        static instance: ::protobuf::rt::LazyV2<StorageLimitsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StorageLimitsResponse::new)
    }
}

impl ::protobuf::Clear for StorageLimitsResponse {
    fn clear(&mut self) {
        self.limits.clear();
        self.units = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StorageLimitsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageLimitsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StorageLimit {
    // message fields
    pub store_type: StoreType,
    pub name: ::std::string::String,
    pub limit: u64,
    pub used: u64,
    pub earliestTimestamp: u64,
    pub earliestHash: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StorageLimit {
    fn default() -> &'a StorageLimit {
        <StorageLimit as ::protobuf::Message>::default_instance()
    }
}

impl StorageLimit {
    pub fn new() -> StorageLimit {
        ::std::default::Default::default()
    }

    // .StoreType store_type = 1;


    pub fn get_store_type(&self) -> StoreType {
        self.store_type
    }
    pub fn clear_store_type(&mut self) {
        self.store_type = StoreType::STORE_TYPE_NONE;
    }

    // Param is passed by value, moved
    pub fn set_store_type(&mut self, v: StoreType) {
        self.store_type = v;
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // uint64 limit = 3;


    pub fn get_limit(&self) -> u64 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u64) {
        self.limit = v;
    }

    // uint64 used = 4;


    pub fn get_used(&self) -> u64 {
        self.used
    }
    pub fn clear_used(&mut self) {
        self.used = 0;
    }

    // Param is passed by value, moved
    pub fn set_used(&mut self, v: u64) {
        self.used = v;
    }

    // uint64 earliestTimestamp = 5;


    pub fn get_earliestTimestamp(&self) -> u64 {
        self.earliestTimestamp
    }
    pub fn clear_earliestTimestamp(&mut self) {
        self.earliestTimestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_earliestTimestamp(&mut self, v: u64) {
        self.earliestTimestamp = v;
    }

    // bytes earliestHash = 6;


    pub fn get_earliestHash(&self) -> &[u8] {
        &self.earliestHash
    }
    pub fn clear_earliestHash(&mut self) {
        self.earliestHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_earliestHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.earliestHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_earliestHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.earliestHash
    }

    // Take field
    pub fn take_earliestHash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.earliestHash, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for StorageLimit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.store_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.limit = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.used = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.earliestTimestamp = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.earliestHash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.store_type != StoreType::STORE_TYPE_NONE {
            my_size += ::protobuf::rt::enum_size(1, self.store_type);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(3, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.used != 0 {
            my_size += ::protobuf::rt::value_size(4, self.used, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.earliestTimestamp != 0 {
            my_size += ::protobuf::rt::value_size(5, self.earliestTimestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.earliestHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.earliestHash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.store_type != StoreType::STORE_TYPE_NONE {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.store_type))?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.limit != 0 {
            os.write_uint64(3, self.limit)?;
        }
        if self.used != 0 {
            os.write_uint64(4, self.used)?;
        }
        if self.earliestTimestamp != 0 {
            os.write_uint64(5, self.earliestTimestamp)?;
        }
        if !self.earliestHash.is_empty() {
            os.write_bytes(6, &self.earliestHash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StorageLimit {
        StorageLimit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StoreType>>(
                "store_type",
                |m: &StorageLimit| { &m.store_type },
                |m: &mut StorageLimit| { &mut m.store_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &StorageLimit| { &m.name },
                |m: &mut StorageLimit| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "limit",
                |m: &StorageLimit| { &m.limit },
                |m: &mut StorageLimit| { &mut m.limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "used",
                |m: &StorageLimit| { &m.used },
                |m: &mut StorageLimit| { &mut m.used },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "earliestTimestamp",
                |m: &StorageLimit| { &m.earliestTimestamp },
                |m: &mut StorageLimit| { &mut m.earliestTimestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "earliestHash",
                |m: &StorageLimit| { &m.earliestHash },
                |m: &mut StorageLimit| { &mut m.earliestHash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StorageLimit>(
                "StorageLimit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StorageLimit {
        static instance: ::protobuf::rt::LazyV2<StorageLimit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StorageLimit::new)
    }
}

impl ::protobuf::Clear for StorageLimit {
    fn clear(&mut self) {
        self.store_type = StoreType::STORE_TYPE_NONE;
        self.name.clear();
        self.limit = 0;
        self.used = 0;
        self.earliestTimestamp = 0;
        self.earliestHash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StorageLimit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageLimit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UsernameProofRequest {
    // message fields
    pub name: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UsernameProofRequest {
    fn default() -> &'a UsernameProofRequest {
        <UsernameProofRequest as ::protobuf::Message>::default_instance()
    }
}

impl UsernameProofRequest {
    pub fn new() -> UsernameProofRequest {
        ::std::default::Default::default()
    }

    // bytes name = 1;


    pub fn get_name(&self) -> &[u8] {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::vec::Vec<u8>) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.name, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for UsernameProofRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_bytes(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UsernameProofRequest {
        UsernameProofRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "name",
                |m: &UsernameProofRequest| { &m.name },
                |m: &mut UsernameProofRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UsernameProofRequest>(
                "UsernameProofRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UsernameProofRequest {
        static instance: ::protobuf::rt::LazyV2<UsernameProofRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UsernameProofRequest::new)
    }
}

impl ::protobuf::Clear for UsernameProofRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UsernameProofRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UsernameProofRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UsernameProofsResponse {
    // message fields
    pub proofs: ::protobuf::RepeatedField<super::username_proof::UserNameProof>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UsernameProofsResponse {
    fn default() -> &'a UsernameProofsResponse {
        <UsernameProofsResponse as ::protobuf::Message>::default_instance()
    }
}

impl UsernameProofsResponse {
    pub fn new() -> UsernameProofsResponse {
        ::std::default::Default::default()
    }

    // repeated .UserNameProof proofs = 1;


    pub fn get_proofs(&self) -> &[super::username_proof::UserNameProof] {
        &self.proofs
    }
    pub fn clear_proofs(&mut self) {
        self.proofs.clear();
    }

    // Param is passed by value, moved
    pub fn set_proofs(&mut self, v: ::protobuf::RepeatedField<super::username_proof::UserNameProof>) {
        self.proofs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_proofs(&mut self) -> &mut ::protobuf::RepeatedField<super::username_proof::UserNameProof> {
        &mut self.proofs
    }

    // Take field
    pub fn take_proofs(&mut self) -> ::protobuf::RepeatedField<super::username_proof::UserNameProof> {
        ::std::mem::replace(&mut self.proofs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for UsernameProofsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.proofs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.proofs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.proofs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.proofs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UsernameProofsResponse {
        UsernameProofsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::username_proof::UserNameProof>>(
                "proofs",
                |m: &UsernameProofsResponse| { &m.proofs },
                |m: &mut UsernameProofsResponse| { &mut m.proofs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UsernameProofsResponse>(
                "UsernameProofsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UsernameProofsResponse {
        static instance: ::protobuf::rt::LazyV2<UsernameProofsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UsernameProofsResponse::new)
    }
}

impl ::protobuf::Clear for UsernameProofsResponse {
    fn clear(&mut self) {
        self.proofs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UsernameProofsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UsernameProofsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VerificationRequest {
    // message fields
    pub fid: u64,
    pub address: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerificationRequest {
    fn default() -> &'a VerificationRequest {
        <VerificationRequest as ::protobuf::Message>::default_instance()
    }
}

impl VerificationRequest {
    pub fn new() -> VerificationRequest {
        ::std::default::Default::default()
    }

    // uint64 fid = 1;


    pub fn get_fid(&self) -> u64 {
        self.fid
    }
    pub fn clear_fid(&mut self) {
        self.fid = 0;
    }

    // Param is passed by value, moved
    pub fn set_fid(&mut self, v: u64) {
        self.fid = v;
    }

    // bytes address = 2;


    pub fn get_address(&self) -> &[u8] {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for VerificationRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fid = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fid, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if !self.address.is_empty() {
            os.write_bytes(2, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerificationRequest {
        VerificationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fid",
                |m: &VerificationRequest| { &m.fid },
                |m: &mut VerificationRequest| { &mut m.fid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "address",
                |m: &VerificationRequest| { &m.address },
                |m: &mut VerificationRequest| { &mut m.address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VerificationRequest>(
                "VerificationRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VerificationRequest {
        static instance: ::protobuf::rt::LazyV2<VerificationRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VerificationRequest::new)
    }
}

impl ::protobuf::Clear for VerificationRequest {
    fn clear(&mut self) {
        self.fid = 0;
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerificationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerificationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignerRequest {
    // message fields
    pub fid: u64,
    pub signer: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignerRequest {
    fn default() -> &'a SignerRequest {
        <SignerRequest as ::protobuf::Message>::default_instance()
    }
}

impl SignerRequest {
    pub fn new() -> SignerRequest {
        ::std::default::Default::default()
    }

    // uint64 fid = 1;


    pub fn get_fid(&self) -> u64 {
        self.fid
    }
    pub fn clear_fid(&mut self) {
        self.fid = 0;
    }

    // Param is passed by value, moved
    pub fn set_fid(&mut self, v: u64) {
        self.fid = v;
    }

    // bytes signer = 2;


    pub fn get_signer(&self) -> &[u8] {
        &self.signer
    }
    pub fn clear_signer(&mut self) {
        self.signer.clear();
    }

    // Param is passed by value, moved
    pub fn set_signer(&mut self, v: ::std::vec::Vec<u8>) {
        self.signer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signer
    }

    // Take field
    pub fn take_signer(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signer, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SignerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fid = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.signer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fid, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.signer);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if !self.signer.is_empty() {
            os.write_bytes(2, &self.signer)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignerRequest {
        SignerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fid",
                |m: &SignerRequest| { &m.fid },
                |m: &mut SignerRequest| { &mut m.fid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "signer",
                |m: &SignerRequest| { &m.signer },
                |m: &mut SignerRequest| { &mut m.signer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SignerRequest>(
                "SignerRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SignerRequest {
        static instance: ::protobuf::rt::LazyV2<SignerRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SignerRequest::new)
    }
}

impl ::protobuf::Clear for SignerRequest {
    fn clear(&mut self) {
        self.fid = 0;
        self.signer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinkRequest {
    // message fields
    pub fid: u64,
    pub link_type: ::std::string::String,
    // message oneof groups
    pub target: ::std::option::Option<LinkRequest_oneof_target>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinkRequest {
    fn default() -> &'a LinkRequest {
        <LinkRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum LinkRequest_oneof_target {
    target_fid(u64),
}

impl LinkRequest {
    pub fn new() -> LinkRequest {
        ::std::default::Default::default()
    }

    // uint64 fid = 1;


    pub fn get_fid(&self) -> u64 {
        self.fid
    }
    pub fn clear_fid(&mut self) {
        self.fid = 0;
    }

    // Param is passed by value, moved
    pub fn set_fid(&mut self, v: u64) {
        self.fid = v;
    }

    // string link_type = 2;


    pub fn get_link_type(&self) -> &str {
        &self.link_type
    }
    pub fn clear_link_type(&mut self) {
        self.link_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_link_type(&mut self, v: ::std::string::String) {
        self.link_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_link_type(&mut self) -> &mut ::std::string::String {
        &mut self.link_type
    }

    // Take field
    pub fn take_link_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.link_type, ::std::string::String::new())
    }

    // uint64 target_fid = 3;


    pub fn get_target_fid(&self) -> u64 {
        match self.target {
            ::std::option::Option::Some(LinkRequest_oneof_target::target_fid(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_target_fid(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target_fid(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(LinkRequest_oneof_target::target_fid(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_target_fid(&mut self, v: u64) {
        self.target = ::std::option::Option::Some(LinkRequest_oneof_target::target_fid(v))
    }
}

impl ::protobuf::Message for LinkRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fid = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.link_type)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target = ::std::option::Option::Some(LinkRequest_oneof_target::target_fid(is.read_uint64()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fid, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.link_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.link_type);
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &LinkRequest_oneof_target::target_fid(v) => {
                    my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if !self.link_type.is_empty() {
            os.write_string(2, &self.link_type)?;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &LinkRequest_oneof_target::target_fid(v) => {
                    os.write_uint64(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinkRequest {
        LinkRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fid",
                |m: &LinkRequest| { &m.fid },
                |m: &mut LinkRequest| { &mut m.fid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "link_type",
                |m: &LinkRequest| { &m.link_type },
                |m: &mut LinkRequest| { &mut m.link_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                "target_fid",
                LinkRequest::has_target_fid,
                LinkRequest::get_target_fid,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LinkRequest>(
                "LinkRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LinkRequest {
        static instance: ::protobuf::rt::LazyV2<LinkRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LinkRequest::new)
    }
}

impl ::protobuf::Clear for LinkRequest {
    fn clear(&mut self) {
        self.fid = 0;
        self.link_type.clear();
        self.target = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinkRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinksByFidRequest {
    // message fields
    pub fid: u64,
    pub link_type: ::std::string::String,
    pub page_size: u32,
    pub page_token: ::std::vec::Vec<u8>,
    pub reverse: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinksByFidRequest {
    fn default() -> &'a LinksByFidRequest {
        <LinksByFidRequest as ::protobuf::Message>::default_instance()
    }
}

impl LinksByFidRequest {
    pub fn new() -> LinksByFidRequest {
        ::std::default::Default::default()
    }

    // uint64 fid = 1;


    pub fn get_fid(&self) -> u64 {
        self.fid
    }
    pub fn clear_fid(&mut self) {
        self.fid = 0;
    }

    // Param is passed by value, moved
    pub fn set_fid(&mut self, v: u64) {
        self.fid = v;
    }

    // string link_type = 2;


    pub fn get_link_type(&self) -> &str {
        &self.link_type
    }
    pub fn clear_link_type(&mut self) {
        self.link_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_link_type(&mut self, v: ::std::string::String) {
        self.link_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_link_type(&mut self) -> &mut ::std::string::String {
        &mut self.link_type
    }

    // Take field
    pub fn take_link_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.link_type, ::std::string::String::new())
    }

    // uint32 page_size = 3;


    pub fn get_page_size(&self) -> u32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: u32) {
        self.page_size = v;
    }

    // bytes page_token = 4;


    pub fn get_page_token(&self) -> &[u8] {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.page_token, ::std::vec::Vec::new())
    }

    // bool reverse = 5;


    pub fn get_reverse(&self) -> bool {
        self.reverse
    }
    pub fn clear_reverse(&mut self) {
        self.reverse = false;
    }

    // Param is passed by value, moved
    pub fn set_reverse(&mut self, v: bool) {
        self.reverse = v;
    }
}

impl ::protobuf::Message for LinksByFidRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fid = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.link_type)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page_size = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.page_token)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reverse = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::value_size(1, self.fid, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.link_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.link_type);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.page_token);
        }
        if self.reverse != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if !self.link_type.is_empty() {
            os.write_string(2, &self.link_type)?;
        }
        if self.page_size != 0 {
            os.write_uint32(3, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_bytes(4, &self.page_token)?;
        }
        if self.reverse != false {
            os.write_bool(5, self.reverse)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinksByFidRequest {
        LinksByFidRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "fid",
                |m: &LinksByFidRequest| { &m.fid },
                |m: &mut LinksByFidRequest| { &mut m.fid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "link_type",
                |m: &LinksByFidRequest| { &m.link_type },
                |m: &mut LinksByFidRequest| { &mut m.link_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page_size",
                |m: &LinksByFidRequest| { &m.page_size },
                |m: &mut LinksByFidRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "page_token",
                |m: &LinksByFidRequest| { &m.page_token },
                |m: &mut LinksByFidRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reverse",
                |m: &LinksByFidRequest| { &m.reverse },
                |m: &mut LinksByFidRequest| { &mut m.reverse },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LinksByFidRequest>(
                "LinksByFidRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LinksByFidRequest {
        static instance: ::protobuf::rt::LazyV2<LinksByFidRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LinksByFidRequest::new)
    }
}

impl ::protobuf::Clear for LinksByFidRequest {
    fn clear(&mut self) {
        self.fid = 0;
        self.link_type.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.reverse = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinksByFidRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinksByFidRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinksByTargetRequest {
    // message fields
    pub link_type: ::std::string::String,
    pub page_size: u32,
    pub page_token: ::std::vec::Vec<u8>,
    pub reverse: bool,
    // message oneof groups
    pub target: ::std::option::Option<LinksByTargetRequest_oneof_target>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinksByTargetRequest {
    fn default() -> &'a LinksByTargetRequest {
        <LinksByTargetRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum LinksByTargetRequest_oneof_target {
    target_fid(u64),
}

impl LinksByTargetRequest {
    pub fn new() -> LinksByTargetRequest {
        ::std::default::Default::default()
    }

    // uint64 target_fid = 1;


    pub fn get_target_fid(&self) -> u64 {
        match self.target {
            ::std::option::Option::Some(LinksByTargetRequest_oneof_target::target_fid(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_target_fid(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target_fid(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(LinksByTargetRequest_oneof_target::target_fid(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_target_fid(&mut self, v: u64) {
        self.target = ::std::option::Option::Some(LinksByTargetRequest_oneof_target::target_fid(v))
    }

    // string link_type = 2;


    pub fn get_link_type(&self) -> &str {
        &self.link_type
    }
    pub fn clear_link_type(&mut self) {
        self.link_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_link_type(&mut self, v: ::std::string::String) {
        self.link_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_link_type(&mut self) -> &mut ::std::string::String {
        &mut self.link_type
    }

    // Take field
    pub fn take_link_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.link_type, ::std::string::String::new())
    }

    // uint32 page_size = 3;


    pub fn get_page_size(&self) -> u32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: u32) {
        self.page_size = v;
    }

    // bytes page_token = 4;


    pub fn get_page_token(&self) -> &[u8] {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.page_token, ::std::vec::Vec::new())
    }

    // bool reverse = 5;


    pub fn get_reverse(&self) -> bool {
        self.reverse
    }
    pub fn clear_reverse(&mut self) {
        self.reverse = false;
    }

    // Param is passed by value, moved
    pub fn set_reverse(&mut self, v: bool) {
        self.reverse = v;
    }
}

impl ::protobuf::Message for LinksByTargetRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target = ::std::option::Option::Some(LinksByTargetRequest_oneof_target::target_fid(is.read_uint64()?));
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.link_type)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.page_size = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.page_token)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.reverse = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.link_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.link_type);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.page_token);
        }
        if self.reverse != false {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &LinksByTargetRequest_oneof_target::target_fid(v) => {
                    my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.link_type.is_empty() {
            os.write_string(2, &self.link_type)?;
        }
        if self.page_size != 0 {
            os.write_uint32(3, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_bytes(4, &self.page_token)?;
        }
        if self.reverse != false {
            os.write_bool(5, self.reverse)?;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &LinksByTargetRequest_oneof_target::target_fid(v) => {
                    os.write_uint64(1, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinksByTargetRequest {
        LinksByTargetRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor::<_>(
                "target_fid",
                LinksByTargetRequest::has_target_fid,
                LinksByTargetRequest::get_target_fid,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "link_type",
                |m: &LinksByTargetRequest| { &m.link_type },
                |m: &mut LinksByTargetRequest| { &mut m.link_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "page_size",
                |m: &LinksByTargetRequest| { &m.page_size },
                |m: &mut LinksByTargetRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "page_token",
                |m: &LinksByTargetRequest| { &m.page_token },
                |m: &mut LinksByTargetRequest| { &mut m.page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "reverse",
                |m: &LinksByTargetRequest| { &m.reverse },
                |m: &mut LinksByTargetRequest| { &mut m.reverse },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LinksByTargetRequest>(
                "LinksByTargetRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LinksByTargetRequest {
        static instance: ::protobuf::rt::LazyV2<LinksByTargetRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LinksByTargetRequest::new)
    }
}

impl ::protobuf::Clear for LinksByTargetRequest {
    fn clear(&mut self) {
        self.target = ::std::option::Option::None;
        self.link_type.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.reverse = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinksByTargetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinksByTargetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IdRegistryEventByAddressRequest {
    // message fields
    pub address: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IdRegistryEventByAddressRequest {
    fn default() -> &'a IdRegistryEventByAddressRequest {
        <IdRegistryEventByAddressRequest as ::protobuf::Message>::default_instance()
    }
}

impl IdRegistryEventByAddressRequest {
    pub fn new() -> IdRegistryEventByAddressRequest {
        ::std::default::Default::default()
    }

    // bytes address = 1;


    pub fn get_address(&self) -> &[u8] {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for IdRegistryEventByAddressRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IdRegistryEventByAddressRequest {
        IdRegistryEventByAddressRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "address",
                |m: &IdRegistryEventByAddressRequest| { &m.address },
                |m: &mut IdRegistryEventByAddressRequest| { &mut m.address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IdRegistryEventByAddressRequest>(
                "IdRegistryEventByAddressRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IdRegistryEventByAddressRequest {
        static instance: ::protobuf::rt::LazyV2<IdRegistryEventByAddressRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IdRegistryEventByAddressRequest::new)
    }
}

impl ::protobuf::Clear for IdRegistryEventByAddressRequest {
    fn clear(&mut self) {
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IdRegistryEventByAddressRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IdRegistryEventByAddressRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContactInfoResponse {
    // message fields
    pub contacts: ::protobuf::RepeatedField<super::gossip::ContactInfoContentBody>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContactInfoResponse {
    fn default() -> &'a ContactInfoResponse {
        <ContactInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl ContactInfoResponse {
    pub fn new() -> ContactInfoResponse {
        ::std::default::Default::default()
    }

    // repeated .ContactInfoContentBody contacts = 1;


    pub fn get_contacts(&self) -> &[super::gossip::ContactInfoContentBody] {
        &self.contacts
    }
    pub fn clear_contacts(&mut self) {
        self.contacts.clear();
    }

    // Param is passed by value, moved
    pub fn set_contacts(&mut self, v: ::protobuf::RepeatedField<super::gossip::ContactInfoContentBody>) {
        self.contacts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_contacts(&mut self) -> &mut ::protobuf::RepeatedField<super::gossip::ContactInfoContentBody> {
        &mut self.contacts
    }

    // Take field
    pub fn take_contacts(&mut self) -> ::protobuf::RepeatedField<super::gossip::ContactInfoContentBody> {
        ::std::mem::replace(&mut self.contacts, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ContactInfoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.contacts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.contacts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.contacts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.contacts {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContactInfoResponse {
        ContactInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::gossip::ContactInfoContentBody>>(
                "contacts",
                |m: &ContactInfoResponse| { &m.contacts },
                |m: &mut ContactInfoResponse| { &mut m.contacts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContactInfoResponse>(
                "ContactInfoResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContactInfoResponse {
        static instance: ::protobuf::rt::LazyV2<ContactInfoResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContactInfoResponse::new)
    }
}

impl ::protobuf::Clear for ContactInfoResponse {
    fn clear(&mut self) {
        self.contacts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContactInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContactInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ValidationResponse {
    // message fields
    pub valid: bool,
    pub message: ::protobuf::SingularPtrField<super::message::Message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ValidationResponse {
    fn default() -> &'a ValidationResponse {
        <ValidationResponse as ::protobuf::Message>::default_instance()
    }
}

impl ValidationResponse {
    pub fn new() -> ValidationResponse {
        ::std::default::Default::default()
    }

    // bool valid = 1;


    pub fn get_valid(&self) -> bool {
        self.valid
    }
    pub fn clear_valid(&mut self) {
        self.valid = false;
    }

    // Param is passed by value, moved
    pub fn set_valid(&mut self, v: bool) {
        self.valid = v;
    }

    // .Message message = 2;


    pub fn get_message(&self) -> &super::message::Message {
        self.message.as_ref().unwrap_or_else(|| <super::message::Message as ::protobuf::Message>::default_instance())
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: super::message::Message) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut super::message::Message {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> super::message::Message {
        self.message.take().unwrap_or_else(|| super::message::Message::new())
    }
}

impl ::protobuf::Message for ValidationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.valid = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.valid != false {
            my_size += 2;
        }
        if let Some(ref v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.valid != false {
            os.write_bool(1, self.valid)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ValidationResponse {
        ValidationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "valid",
                |m: &ValidationResponse| { &m.valid },
                |m: &mut ValidationResponse| { &mut m.valid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::message::Message>>(
                "message",
                |m: &ValidationResponse| { &m.message },
                |m: &mut ValidationResponse| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ValidationResponse>(
                "ValidationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ValidationResponse {
        static instance: ::protobuf::rt::LazyV2<ValidationResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ValidationResponse::new)
    }
}

impl ::protobuf::Clear for ValidationResponse {
    fn clear(&mut self) {
        self.valid = false;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ValidationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum StoreType {
    STORE_TYPE_NONE = 0,
    STORE_TYPE_CASTS = 1,
    STORE_TYPE_LINKS = 2,
    STORE_TYPE_REACTIONS = 3,
    STORE_TYPE_USER_DATA = 4,
    STORE_TYPE_VERIFICATIONS = 5,
    STORE_TYPE_USERNAME_PROOFS = 6,
}

impl ::protobuf::ProtobufEnum for StoreType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StoreType> {
        match value {
            0 => ::std::option::Option::Some(StoreType::STORE_TYPE_NONE),
            1 => ::std::option::Option::Some(StoreType::STORE_TYPE_CASTS),
            2 => ::std::option::Option::Some(StoreType::STORE_TYPE_LINKS),
            3 => ::std::option::Option::Some(StoreType::STORE_TYPE_REACTIONS),
            4 => ::std::option::Option::Some(StoreType::STORE_TYPE_USER_DATA),
            5 => ::std::option::Option::Some(StoreType::STORE_TYPE_VERIFICATIONS),
            6 => ::std::option::Option::Some(StoreType::STORE_TYPE_USERNAME_PROOFS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [StoreType] = &[
            StoreType::STORE_TYPE_NONE,
            StoreType::STORE_TYPE_CASTS,
            StoreType::STORE_TYPE_LINKS,
            StoreType::STORE_TYPE_REACTIONS,
            StoreType::STORE_TYPE_USER_DATA,
            StoreType::STORE_TYPE_VERIFICATIONS,
            StoreType::STORE_TYPE_USERNAME_PROOFS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<StoreType>("StoreType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for StoreType {
}

impl ::std::default::Default for StoreType {
    fn default() -> Self {
        StoreType::STORE_TYPE_NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for StoreType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x16request_response.proto\x1a\rmessage.proto\x1a\x13onchain_event.pro\
    to\x1a\x0fhub_event.proto\x1a\x14username_proof.proto\x1a\x0cgossip.prot\
    o\"\t\n\x05Empty:\0\"\xa9\x01\n\x10SubscribeRequest\x120\n\x0bevent_type\
    s\x18\x01\x20\x03(\x0e2\r.HubEventTypeR\neventTypesB\0\x12\x19\n\x07from\
    _id\x18\x02\x20\x01(\x04R\x06fromIdB\0\x12#\n\x0ctotal_shards\x18\x03\
    \x20\x01(\x04R\x0btotalShardsB\0\x12!\n\x0bshard_index\x18\x04\x20\x01(\
    \x04R\nshardIndexB\0:\0\"\"\n\x0cEventRequest\x12\x10\n\x02id\x18\x01\
    \x20\x01(\x04R\x02idB\0:\0\"/\n\x0eHubInfoRequest\x12\x1b\n\x08db_stats\
    \x18\x01\x20\x01(\x08R\x07dbStatsB\0:\0\"\xfa\x01\n\x0fHubInfoResponse\
    \x12\x1a\n\x07version\x18\x01\x20\x01(\tR\x07versionB\0\x12\x1f\n\nis_sy\
    ncing\x18\x02\x20\x01(\x08R\tisSyncingB\0\x12\x1c\n\x08nickname\x18\x03\
    \x20\x01(\tR\x08nicknameB\0\x12\x1d\n\troot_hash\x18\x04\x20\x01(\tR\x08\
    rootHashB\0\x12%\n\x08db_stats\x18\x05\x20\x01(\x0b2\x08.DbStatsR\x07dbS\
    tatsB\0\x12\x18\n\x06peerId\x18\x06\x20\x01(\tR\x06peerIdB\0\x12*\n\x10h\
    ub_operator_fid\x18\x07\x20\x01(\x04R\x0ehubOperatorFidB\0:\0\"\x84\x01\
    \n\x07DbStats\x12#\n\x0cnum_messages\x18\x01\x20\x01(\x04R\x0bnumMessage\
    sB\0\x12&\n\x0enum_fid_events\x18\x02\x20\x01(\x04R\x0cnumFidEventsB\0\
    \x12*\n\x10num_fname_events\x18\x03\x20\x01(\x04R\x0enumFnameEventsB\0:\
    \0\"/\n\x11SyncStatusRequest\x12\x18\n\x06peerId\x18\x01\x20\x01(\tR\x06\
    peerIdB\0:\0\"\x90\x01\n\x12SyncStatusResponse\x12\x1f\n\nis_syncing\x18\
    \x01\x20\x01(\x08R\tisSyncingB\0\x12.\n\x0bsync_status\x18\x02\x20\x03(\
    \x0b2\x0b.SyncStatusR\nsyncStatusB\0\x12'\n\x0eengine_started\x18\x03\
    \x20\x01(\x08R\rengineStartedB\0:\0\"\xd0\x02\n\nSyncStatus\x12\x18\n\
    \x06peerId\x18\x01\x20\x01(\tR\x06peerIdB\0\x12\x18\n\x06inSync\x18\x02\
    \x20\x01(\tR\x06inSyncB\0\x12\x20\n\nshouldSync\x18\x03\x20\x01(\x08R\ns\
    houldSyncB\0\x12,\n\x10divergencePrefix\x18\x04\x20\x01(\tR\x10divergenc\
    ePrefixB\0\x124\n\x14divergenceSecondsAgo\x18\x05\x20\x01(\x05R\x14diver\
    genceSecondsAgoB\0\x12&\n\rtheirMessages\x18\x06\x20\x01(\x04R\rtheirMes\
    sagesB\0\x12\"\n\x0bourMessages\x18\x07\x20\x01(\x04R\x0bourMessagesB\0\
    \x12\"\n\x0blastBadSync\x18\x08\x20\x01(\x03R\x0blastBadSyncB\0\x12\x16\
    \n\x05score\x18\t\x20\x01(\x03R\x05scoreB\0:\0\"\xaa\x01\n\x18TrieNodeMe\
    tadataResponse\x12\x18\n\x06prefix\x18\x01\x20\x01(\x0cR\x06prefixB\0\
    \x12#\n\x0cnum_messages\x18\x02\x20\x01(\x04R\x0bnumMessagesB\0\x12\x14\
    \n\x04hash\x18\x03\x20\x01(\tR\x04hashB\0\x127\n\x08children\x18\x04\x20\
    \x03(\x0b2\x19.TrieNodeMetadataResponseR\x08childrenB\0:\0\"\xa5\x01\n\
    \x18TrieNodeSnapshotResponse\x12\x18\n\x06prefix\x18\x01\x20\x01(\x0cR\
    \x06prefixB\0\x12)\n\x0fexcluded_hashes\x18\x02\x20\x03(\tR\x0eexcludedH\
    ashesB\0\x12#\n\x0cnum_messages\x18\x03\x20\x01(\x04R\x0bnumMessagesB\0\
    \x12\x1d\n\troot_hash\x18\x04\x20\x01(\tR\x08rootHashB\0:\0\",\n\x0eTrie\
    NodePrefix\x12\x18\n\x06prefix\x18\x01\x20\x01(\x0cR\x06prefixB\0:\0\"(\
    \n\x07SyncIds\x12\x1b\n\x08sync_ids\x18\x01\x20\x03(\x0cR\x07syncIdsB\0:\
    \0\"~\n\nFidRequest\x12\x12\n\x03fid\x18\x01\x20\x01(\x04R\x03fidB\0\x12\
    \x1d\n\tpage_size\x18\x02\x20\x01(\rR\x08pageSizeB\0\x12\x1f\n\npage_tok\
    en\x18\x03\x20\x01(\x0cR\tpageTokenB\0\x12\x1a\n\x07reverse\x18\x04\x20\
    \x01(\x08R\x07reverseB\0:\0\"k\n\x0bFidsRequest\x12\x1d\n\tpage_size\x18\
    \x01\x20\x01(\rR\x08pageSizeB\0\x12\x1f\n\npage_token\x18\x02\x20\x01(\
    \x0cR\tpageTokenB\0\x12\x1a\n\x07reverse\x18\x03\x20\x01(\x08R\x07revers\
    eB\0:\0\"P\n\x0cFidsResponse\x12\x14\n\x04fids\x18\x01\x20\x03(\x04R\x04\
    fidsB\0\x12(\n\x0fnext_page_token\x18\x02\x20\x01(\x0cR\rnextPageTokenB\
    \0:\0\"f\n\x10MessagesResponse\x12&\n\x08messages\x18\x01\x20\x03(\x0b2\
    \x08.MessageR\x08messagesB\0\x12(\n\x0fnext_page_token\x18\x02\x20\x01(\
    \x0cR\rnextPageTokenB\0:\0\"\xd4\x01\n\x14CastsByParentRequest\x121\n\
    \x0eparent_cast_id\x18\x01\x20\x01(\x0b2\x07.CastIdH\0R\x0cparentCastIdB\
    \0\x12!\n\nparent_url\x18\x05\x20\x01(\tH\0R\tparentUrlB\0\x12\x1d\n\tpa\
    ge_size\x18\x02\x20\x01(\rR\x08pageSizeB\0\x12\x1f\n\npage_token\x18\x03\
    \x20\x01(\x0cR\tpageTokenB\0\x12\x1a\n\x07reverse\x18\x04\x20\x01(\x08R\
    \x07reverseB\0B\x08\n\x06parent:\0\"\xbd\x01\n\x0fReactionRequest\x12\
    \x12\n\x03fid\x18\x01\x20\x01(\x04R\x03fidB\0\x124\n\rreaction_type\x18\
    \x02\x20\x01(\x0e2\r.ReactionTypeR\x0creactionTypeB\0\x121\n\x0etarget_c\
    ast_id\x18\x03\x20\x01(\x0b2\x07.CastIdH\0R\x0ctargetCastIdB\0\x12!\n\nt\
    arget_url\x18\x04\x20\x01(\tH\0R\ttargetUrlB\0B\x08\n\x06target:\0\"\xbf\
    \x01\n\x15ReactionsByFidRequest\x12\x12\n\x03fid\x18\x01\x20\x01(\x04R\
    \x03fidB\0\x124\n\rreaction_type\x18\x02\x20\x01(\x0e2\r.ReactionTypeR\
    \x0creactionTypeB\0\x12\x1d\n\tpage_size\x18\x03\x20\x01(\rR\x08pageSize\
    B\0\x12\x1f\n\npage_token\x18\x04\x20\x01(\x0cR\tpageTokenB\0\x12\x1a\n\
    \x07reverse\x18\x05\x20\x01(\x08R\x07reverseB\0:\0\"\x8e\x02\n\x18Reacti\
    onsByTargetRequest\x121\n\x0etarget_cast_id\x18\x01\x20\x01(\x0b2\x07.Ca\
    stIdH\0R\x0ctargetCastIdB\0\x12!\n\ntarget_url\x18\x06\x20\x01(\tH\0R\tt\
    argetUrlB\0\x124\n\rreaction_type\x18\x02\x20\x01(\x0e2\r.ReactionTypeR\
    \x0creactionTypeB\0\x12\x1d\n\tpage_size\x18\x03\x20\x01(\rR\x08pageSize\
    B\0\x12\x1f\n\npage_token\x18\x04\x20\x01(\x0cR\tpageTokenB\0\x12\x1a\n\
    \x07reverse\x18\x05\x20\x01(\x08R\x07reverseB\0B\x08\n\x06target:\0\"^\n\
    \x0fUserDataRequest\x12\x12\n\x03fid\x18\x01\x20\x01(\x04R\x03fidB\0\x12\
    5\n\x0euser_data_type\x18\x02\x20\x01(\x0e2\r.UserDataTypeR\x0cuserDataT\
    ypeB\0:\0\"2\n\x18NameRegistryEventRequest\x12\x14\n\x04name\x18\x01\x20\
    \x01(\x0cR\x04nameB\0:\0\"1\n\x19RentRegistryEventsRequest\x12\x12\n\x03\
    fid\x18\x01\x20\x01(\x04R\x03fidB\0:\0\"\xbb\x01\n\x13OnChainEventReques\
    t\x12\x12\n\x03fid\x18\x01\x20\x01(\x04R\x03fidB\0\x122\n\nevent_type\
    \x18\x02\x20\x01(\x0e2\x11.OnChainEventTypeR\teventTypeB\0\x12\x1d\n\tpa\
    ge_size\x18\x03\x20\x01(\rR\x08pageSizeB\0\x12\x1f\n\npage_token\x18\x04\
    \x20\x01(\x0cR\tpageTokenB\0\x12\x1a\n\x07reverse\x18\x05\x20\x01(\x08R\
    \x07reverseB\0:\0\"k\n\x14OnChainEventResponse\x12'\n\x06events\x18\x01\
    \x20\x03(\x0b2\r.OnChainEventR\x06eventsB\0\x12(\n\x0fnext_page_token\
    \x18\x02\x20\x01(\x0cR\rnextPageTokenB\0:\0\"Z\n\x15StorageLimitsRespons\
    e\x12'\n\x06limits\x18\x01\x20\x03(\x0b2\r.StorageLimitR\x06limitsB\0\
    \x12\x16\n\x05units\x18\x02\x20\x01(\rR\x05unitsB\0:\0\"\xd7\x01\n\x0cSt\
    orageLimit\x12+\n\nstore_type\x18\x01\x20\x01(\x0e2\n.StoreTypeR\tstoreT\
    ypeB\0\x12\x14\n\x04name\x18\x02\x20\x01(\tR\x04nameB\0\x12\x16\n\x05lim\
    it\x18\x03\x20\x01(\x04R\x05limitB\0\x12\x14\n\x04used\x18\x04\x20\x01(\
    \x04R\x04usedB\0\x12.\n\x11earliestTimestamp\x18\x05\x20\x01(\x04R\x11ea\
    rliestTimestampB\0\x12$\n\x0cearliestHash\x18\x06\x20\x01(\x0cR\x0cearli\
    estHashB\0:\0\".\n\x14UsernameProofRequest\x12\x14\n\x04name\x18\x01\x20\
    \x01(\x0cR\x04nameB\0:\0\"D\n\x16UsernameProofsResponse\x12(\n\x06proofs\
    \x18\x01\x20\x03(\x0b2\x0e.UserNameProofR\x06proofsB\0:\0\"G\n\x13Verifi\
    cationRequest\x12\x12\n\x03fid\x18\x01\x20\x01(\x04R\x03fidB\0\x12\x1a\n\
    \x07address\x18\x02\x20\x01(\x0cR\x07addressB\0:\0\"?\n\rSignerRequest\
    \x12\x12\n\x03fid\x18\x01\x20\x01(\x04R\x03fidB\0\x12\x18\n\x06signer\
    \x18\x02\x20\x01(\x0cR\x06signerB\0:\0\"o\n\x0bLinkRequest\x12\x12\n\x03\
    fid\x18\x01\x20\x01(\x04R\x03fidB\0\x12\x1d\n\tlink_type\x18\x02\x20\x01\
    (\tR\x08linkTypeB\0\x12!\n\ntarget_fid\x18\x03\x20\x01(\x04H\0R\ttargetF\
    idB\0B\x08\n\x06target:\0\"\xa4\x01\n\x11LinksByFidRequest\x12\x12\n\x03\
    fid\x18\x01\x20\x01(\x04R\x03fidB\0\x12\x1d\n\tlink_type\x18\x02\x20\x01\
    (\tR\x08linkTypeB\0\x12\x1d\n\tpage_size\x18\x03\x20\x01(\rR\x08pageSize\
    B\0\x12\x1f\n\npage_token\x18\x04\x20\x01(\x0cR\tpageTokenB\0\x12\x1a\n\
    \x07reverse\x18\x05\x20\x01(\x08R\x07reverseB\0:\0\"\xc0\x01\n\x14LinksB\
    yTargetRequest\x12!\n\ntarget_fid\x18\x01\x20\x01(\x04H\0R\ttargetFidB\0\
    \x12\x1d\n\tlink_type\x18\x02\x20\x01(\tR\x08linkTypeB\0\x12\x1d\n\tpage\
    _size\x18\x03\x20\x01(\rR\x08pageSizeB\0\x12\x1f\n\npage_token\x18\x04\
    \x20\x01(\x0cR\tpageTokenB\0\x12\x1a\n\x07reverse\x18\x05\x20\x01(\x08R\
    \x07reverseB\0B\x08\n\x06target:\0\"?\n\x1fIdRegistryEventByAddressReque\
    st\x12\x1a\n\x07address\x18\x01\x20\x01(\x0cR\x07addressB\0:\0\"N\n\x13C\
    ontactInfoResponse\x125\n\x08contacts\x18\x01\x20\x03(\x0b2\x17.ContactI\
    nfoContentBodyR\x08contactsB\0:\0\"T\n\x12ValidationResponse\x12\x16\n\
    \x05valid\x18\x01\x20\x01(\x08R\x05validB\0\x12$\n\x07message\x18\x02\
    \x20\x01(\x0b2\x08.MessageR\x07messageB\0:\0*\xc0\x01\n\tStoreType\x12\
    \x13\n\x0fSTORE_TYPE_NONE\x10\0\x12\x14\n\x10STORE_TYPE_CASTS\x10\x01\
    \x12\x14\n\x10STORE_TYPE_LINKS\x10\x02\x12\x18\n\x14STORE_TYPE_REACTIONS\
    \x10\x03\x12\x18\n\x14STORE_TYPE_USER_DATA\x10\x04\x12\x1c\n\x18STORE_TY\
    PE_VERIFICATIONS\x10\x05\x12\x1e\n\x1aSTORE_TYPE_USERNAME_PROOFS\x10\x06\
    \x1a\0B\0b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
